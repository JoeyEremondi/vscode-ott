(* generated by Ott 0.28 from: /home/joey/UBC/Oopsla18/ott/minirust.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import Ott.ott_list_core.


Require Import ExtLib.Data.Map.FMapAList.
Require Import ExtLib.Structures.Maps.
Require Import ExtLib.Data.Nat.

Definition exprvar := natLemma eq_exprvar: forall (x y : exprvar), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_exprvar : ott_coq_equality.
Definition alpha := natLemma eq_alpha: forall (x y : alpha), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_alpha : ott_coq_equality.
Definition loc := natLemma eq_loc: forall (x y : loc), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_loc : ott_coq_equality.
Definition A := natLemma eq_A: forall (x y : A), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_A : ott_coq_equality.
Definition SName := natLemma eq_SName: forall (x y : SName), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_SName : ott_coq_equality.
Definition CtorName := natLemma eq_CtorName: forall (x y : CtorName), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_CtorName : ott_coq_equality.
Definition EnumName := natLemma eq_EnumName: forall (x y : EnumName), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_EnumName : ott_coq_equality.
Definition D := natLemma eq_D: forall (x y : D), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_D : ott_coq_equality.
Definition index := nat
Inductive K : Set := 
 | kind_KindStar : K (*r base values *)
 | kind_Constr : K (*r base constraints *)
 | kind_Bound : K (*r base trait bounds *)
 | kind_ArrowKind (K5:K) (K':K) (*r arrow kinds *).

Inductive X : Set := 
 | annvarKindAnn (A5:A) (K5:K).

Inductive T : Set :=  (*r types *)
 | T_var (X5:X) (*r variable *)
 | T_polyarrow (_:list X) (pi5:pi) (T5:T) (T':T) (*r function *)
 | T_TyApp (T5:T) (tau5:T) (*r type application *)
 | T_Tuple (T5:T) (T':T) (*r tuple *)
 | T_StructType (SName5:SName) (*r struct *)
 | T_EnumType (EnumName5:EnumName) (*r enum *)
 | T_UType : T (*r empty tuple *)
 | T_RefType (T5:T) (*r reference *)
 | T_TraitObj (X5:X) (beta5:beta) (*r trait object *)
 | T_Assoc (X5:X) (beta5:beta) (*r associated type *)
 | T_unifVar (alpha5:alpha) (*r unification variables (algorithmic only) *)
with pi : Set :=  (*r constraints *)
 | pi_trtBound (tau5:T) (beta5:beta) (*r type has bound *)
 | pi_forall (_:list X) (pi5:pi) (tau5:T) (beta5:beta) (*r generic constraint *)
 | pi_conj (pi1:pi) (pi2:pi) (*r conjunction *)
 | pi_empty : pi (*r trivial constraint *)
with beta : Set :=  (*r trait bounds *)
 | beta_TraitName (D5:D) (*r trait name *)
 | beta_TypeApp (beta5:beta) (tau5:T) (*r type application *)
 | beta_Assoc (beta5:beta) (X5:X) (tau5:T) (*r associated type specification *)
 | beta_elab (beta5:beta) (f:exprvar) (e5:e) (*r bound with elaborated form *)
with e : Set :=  (*r expressions *)
 | exprVar (x:exprvar) (*r program variable *)
 | exprApp (e5:e) (e':e) (*r function application *)
 | exprCApp (CtorName5:CtorName) (EnumName5:EnumName) (e5:e) (*r enum constructor *)
 | exprmatch (e_5:e) (CtorName1:CtorName) (EnumName5:EnumName) (x1:exprvar) (e1:e) (CtorName2:CtorName) (EnumName':EnumName) (x2:exprvar) (e2:e) (*r pattern matching *)
 | exprLet (x:exprvar) (e5:e) (e':e) (*r variable bindings *)
 | exprAssign (lv5:e) (e':e) (*r assignment *)
 | exprSeq (e5:e) (e':e) (*r sequencing *)
 | exprRef (lv5:e) (*r reference-to *)
 | exprDeref (e5:e) (*r dereference *)
 | exprUnit : e (*r empty tuple (unit) *)
 | exprTuple (e5:e) (e':e) (*r pair (sugar) *)
 | exprfst (e5:e) (*r pair fst (sugar) *)
 | exprsnd (e5:e) (*r pair snd (sugar) *)
 | exprAnnot (e5:e) (T5:T) (*r type annotation *)
 | exprStructInit (SName5:SName) (x1:exprvar) (e1:e) (x2:exprvar) (e2:e) (*r struct creation *)
 | exprStructField (e5:e) (x:exprvar) (*r struct field access *)
 | exprInternal (internal5:internal) (*r internal form *)
with internal : Set :=  (*r internal Forms *)
 | internalRawProc (x:exprvar) (T1:T) (e5:e) (T2:T) (*r raw function *)
 | internalobj (X5:X) (beta5:beta) (e5:e) (T2:T) (f:exprvar) (v5:e) (*r trait object *)
 | internalobjapp (e1:e) (f:exprvar) (e2:e) (*r object method call *)
 | internalspec (e5:e) (_:list T) (*r polymorphic instantiation *)
 | internalgen (_:list X) (e5:e) (*r polymorphic generalization *)
 | internalloc (loc5:loc) (*r store location *).

Inductive fundef : Set := 
 | fundef_fundef (f:exprvar) (_:list X) (x:exprvar) (T1:T) (T2:T) (pi5:pi) (e5:e).

Inductive fundecl : Set := 
 | fundecl_fundecl (f:exprvar) (_:list X) (x:exprvar) (T1:T) (T2:T) (pi5:pi).

Inductive item : Set := 
 | itemstruct (SName5:SName) (_:list X) (x1:exprvar) (T1:T) (x2:exprvar) (T2:T) (*r Struct Definition *)
 | itemenum (EnumName5:EnumName) (_:list X) (CtorName1:CtorName) (T1:T) (CtorName2:CtorName) (T2:T) (*r Enum Definition *)
 | itemtraitdecl (D5:D) (_:list X) (pi5:pi) (X':X) (fundecl5:fundecl) (*r Trait Definition *)
 | itemtraitimpl (_:list X) (D5:D) (_:list T) (T5:T) (pi5:pi) (X':X) (T':T) (fundef5:fundef) (*r Trait Impl *)
 | itemfundef (fundef5:fundef) (*r Function Definition *).

Inductive theta : Set := 
 | theta_pi (pi5:pi)
 | theta_fnval (f:exprvar) (e5:e)
 | theta_item (item5:item).

Inductive gamma : Set := 
 | gamma_evar (x:exprvar) (T5:T)
 | gamma_tvar (X5:X).

Definition Theta : Set := ( list theta ).

Definition Gamma : Set := ( list gamma ).

Inductive prob : Set := 
 | problemsEq (Gamma5:Gamma) (Theta5:Theta) (T1:T) (T2:T)
 | problemsSub (Gamma5:Gamma) (Theta5:Theta) (T1:T) (T2:T)
 | problemsEntails (Gamma5:Gamma) (Theta5:Theta) (pi5:pi)
 | problemsKind (Gamma5:Gamma) (Theta5:Theta) (T5:T) (K5:K).

Inductive P : Set := 
 | probListSeq (_:list prob)
 | probListLiteral (_:list prob)
 | probListUnion (P1:P) (P2:P).

Inductive kinded : Set := 
 | kinded_type (T5:T)
 | kinded_constr (pi5:pi)
 | kinded_impl (beta5:beta).

Inductive CC : Set := 
 | coercionContext_empty : CC
 | coercionContext_spec (_:list T)
 | coercionContext_obj (X5:X) (beta5:beta) (T2:T) (f:exprvar) (v5:e)
 | coercionContext_gen (_:list X) (CC5:CC).

Definition sigma : Type := (alist loc expr).

Inductive V : Set := 
 | varListSeq (_:list alpha)
 | varListLiteral (_:list alpha)
 | varListUnion (V1:V) (V2:V).

Inductive EC : Set := 
 | evalContextApp1 (e5:e)
 | evalContextApp2 (v5:e)
 | evalContextCApp (CtorName5:CtorName) (EnumName5:EnumName)
 | evalContextmatch (CtorName1:CtorName) (EnumName5:EnumName) (x1:exprvar) (e1:e) (CtorName2:CtorName) (EnumName':EnumName) (x2:exprvar) (e2:e)
 | evalContextfst : EC
 | evalContextsnd : EC
 | evalContextLet (x:exprvar) (e':e)
 | evalContextAssign (lv5:e)
 | evalContextSeq (e5:e)
 | evalContextDeref : EC
 | evalContextTuple1 (e':e)
 | evalContextTuple2 (v5:e)
 | evalContextAnnot (T5:T)
 | evalContextStructInit1 (SName5:SName) (x1:exprvar) (x2:exprvar) (e2:e)
 | evalContextStructInit (SName5:SName) (x1:exprvar) (v5:e) (x2:exprvar)
 | evalContextStructField (x:exprvar)
 | evalContextobjapp1 (f:exprvar) (e2:e)
 | evalContextobjapp2 (v5:e) (f:exprvar).

Inductive VList : Set := 
 | varListListvListList (_:list V).

Inductive pretty : Set := 
 | prettytseq (_:list T).

Inductive XD : Set := 
 | assocType_name (X5:X) (beta5:beta).
Lemma eq_K: forall (x y : K), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_K : ott_coq_equality.
Lemma eq_X: forall (x y : X), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_X : ott_coq_equality.
Lemma eq_e: forall (x y : e), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_e : ott_coq_equality.
Lemma eq_internal: forall (x y : internal), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_internal : ott_coq_equality.
Lemma eq_fundef: forall (x y : fundef), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_fundef : ott_coq_equality.
Lemma eq_fundecl: forall (x y : fundecl), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_fundecl : ott_coq_equality.
Lemma eq_item: forall (x y : item), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_item : ott_coq_equality.
Lemma eq_theta: forall (x y : theta), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_theta : ott_coq_equality.
Lemma eq_gamma: forall (x y : gamma), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_gamma : ott_coq_equality.
Lemma eq_prob: forall (x y : prob), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_prob : ott_coq_equality.
Lemma eq_P: forall (x y : P), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_P : ott_coq_equality.
Lemma eq_V: forall (x y : V), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_V : ott_coq_equality.
Lemma eq_EC: forall (x y : EC), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_EC : ott_coq_equality.
Lemma eq_XD: forall (x y : XD), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_XD : ott_coq_equality.
(** induction principles *)
Section K_rect.

Variables
  (P_K : K -> Prop).

Hypothesis
  (H_kind_KindStar : P_K kind_KindStar)
  (H_kind_Constr : P_K kind_Constr)
  (H_kind_Bound : P_K kind_Bound)
  (H_kind_ArrowKind : forall (K5:K), P_K K5 -> forall (K':K), P_K K' -> P_K (kind_ArrowKind K5 K'))
.

Fixpoint K_ott_ind (n:K) : P_K n :=
  match n as x return P_K x with
  | kind_KindStar => H_kind_KindStar 
  | kind_Constr => H_kind_Constr 
  | kind_Bound => H_kind_Bound 
  | (kind_ArrowKind K5 K') => H_kind_ArrowKind K5 (K_ott_ind K5) K' (K_ott_ind K')
end.

End K_rect.
(** definitions *)

(** funs KindOf *)
Fixpoint kindOf (x1:X) : K:=
  match x1 with
  | (annvarKindAnn A5 K5) => K5
end.


(** subrules *)
Definition is_internallv_of_internal (internal5:internal) : bool :=
  match internal5 with
  | (internalRawProc x T1 e5 T2) => false
  | (internalobj X5 beta5 e5 T2 f v5) => false
  | (internalobjapp e1 f e2) => false
  | (internalspec e5 tau_list) => false
  | (internalgen X_list e5) => false
  | (internalloc loc5) => (true)
end.

Fixpoint is_pi_of_pi (pi_6:pi) : bool :=
  match pi_6 with
  | (pi_trtBound tau5 beta5) => ((is_tau_of_T tau5) && (is_beta_of_beta beta5))
  | (pi_forall X_list pi5 tau5 beta5) => ((forall_list (fun (X_:X) => true) X_list) && (is_pi_of_pi pi5) && (is_tau_of_T tau5) && (is_beta_of_beta beta5))
  | (pi_conj pi1 pi2) => ((is_pi_of_pi pi1) && (is_pi_of_pi pi2))
  | pi_empty => (true)
end
with is_internal_of_internal (internal5:internal) : bool :=
  match internal5 with
  | (internalRawProc x T1 e5 T2) => ((is_T_of_T T1) && (is_e_of_e e5) && (is_T_of_T T2))
  | (internalobj X5 beta5 e5 T2 f v5) => ((is_beta_of_beta beta5) && (is_e_of_e e5) && (is_T_of_T T2) && (is_v_of_e v5))
  | (internalobjapp e1 f e2) => ((is_e_of_e e1) && (is_e_of_e e2))
  | (internalspec e5 tau_list) => ((is_e_of_e e5) && (forall_list (fun (tau_:T) => (is_tau_of_T tau_)) tau_list))
  | (internalgen X_list e5) => ((forall_list (fun (X_:X) => true) X_list) && (is_e_of_e e5))
  | (internalloc loc5) => (true)
end
with is_e_of_e (e__6:e) : bool :=
  match e__6 with
  | (exprVar x) => (true)
  | (exprApp e5 e') => ((is_e_of_e e5) && (is_e_of_e e'))
  | (exprCApp CtorName5 EnumName5 e5) => ((is_e_of_e e5))
  | (exprmatch e_5 CtorName1 EnumName5 x1 e1 CtorName2 EnumName' x2 e2) => ((is_e_of_e e_5) && (is_e_of_e e1) && (is_e_of_e e2))
  | (exprLet x e5 e') => ((is_e_of_e e5) && (is_e_of_e e'))
  | (exprAssign lv5 e') => ((is_lv_of_e lv5) && (is_e_of_e e'))
  | (exprSeq e5 e') => ((is_e_of_e e5) && (is_e_of_e e'))
  | (exprRef lv5) => ((is_lv_of_e lv5))
  | (exprDeref e5) => ((is_e_of_e e5))
  | exprUnit => (true)
  | (exprTuple e5 e') => ((is_e_of_e e5) && (is_e_of_e e'))
  | (exprfst e5) => ((is_e_of_e e5))
  | (exprsnd e5) => ((is_e_of_e e5))
  | (exprAnnot e5 T5) => ((is_e_of_e e5) && (is_T_of_T T5))
  | (exprStructInit SName5 x1 e1 x2 e2) => ((is_e_of_e e1) && (is_e_of_e e2))
  | (exprStructField e5 x) => ((is_e_of_e e5))
  | (exprInternal internal5) => ((is_internal_of_internal internal5))
end
with is_beta_of_beta (beta_6:beta) : bool :=
  match beta_6 with
  | (beta_TraitName D5) => (true)
  | (beta_TypeApp beta5 tau5) => ((is_beta_of_beta beta5) && (is_tau_of_T tau5))
  | (beta_Assoc beta5 X5 tau5) => ((is_beta_of_beta beta5) && (is_tau_of_T tau5))
  | (beta_elab beta5 f e5) => ((is_beta_of_beta beta5) && (is_e_of_e e5))
end
with is_T_of_T (T_6:T) : bool :=
  match T_6 with
  | (T_var X5) => (true)
  | (T_polyarrow X_list pi5 T5 T') => ((forall_list (fun (X_:X) => true) X_list) && (is_pi_of_pi pi5) && (is_T_of_T T5) && (is_T_of_T T'))
  | (T_TyApp T5 tau5) => ((is_T_of_T T5) && (is_tau_of_T tau5))
  | (T_Tuple T5 T') => ((is_T_of_T T5) && (is_T_of_T T'))
  | (T_StructType SName5) => (true)
  | (T_EnumType EnumName5) => (true)
  | T_UType => (true)
  | (T_RefType T5) => ((is_T_of_T T5))
  | (T_TraitObj X5 beta5) => ((is_beta_of_beta beta5))
  | (T_Assoc X5 beta5) => ((is_beta_of_beta beta5))
  | (T_unifVar alpha5) => (true)
end
with is_internalValue_of_internal (internal5:internal) : bool :=
  match internal5 with
  | (internalRawProc x T1 e5 T2) => false
  | (internalobj X5 beta5 e5 T2 f v5) => ((is_beta_of_beta beta5) && (is_v_of_e e5) && (is_T_of_T T2) && (is_v_of_e v5))
  | (internalobjapp e1 f e2) => false
  | (internalspec e5 tau_list) => ((is_v_of_e e5) && (forall_list (fun (tau_:T) => (is_tau_of_T tau_)) tau_list))
  | (internalgen X_list e5) => ((forall_list (fun (X_:X) => true) X_list) && (is_v_of_e e5))
  | (internalloc loc5) => (true)
end
with is_v_of_e (e__6:e) : bool :=
  match e__6 with
  | (exprVar x) => false
  | (exprApp e5 e') => false
  | (exprCApp CtorName5 EnumName5 e5) => ((is_v_of_e e5))
  | (exprmatch e_5 CtorName1 EnumName5 x1 e1 CtorName2 EnumName' x2 e2) => false
  | (exprLet x e5 e') => false
  | (exprAssign lv5 e') => false
  | (exprSeq e5 e') => false
  | (exprRef lv5) => ((is_lv_of_e lv5))
  | (exprDeref e5) => ((is_v_of_e e5))
  | exprUnit => (true)
  | (exprTuple e5 e') => ((is_v_of_e e5) && (is_v_of_e e'))
  | (exprfst e5) => false
  | (exprsnd e5) => false
  | (exprAnnot e5 T5) => ((is_v_of_e e5) && (is_T_of_T T5))
  | (exprStructInit SName5 x1 e1 x2 e2) => ((is_v_of_e e1) && (is_v_of_e e2))
  | (exprStructField e5 x) => false
  | (exprInternal internal5) => ((is_internalValue_of_internal internal5))
end
with is_lv_of_e (e__6:e) : bool :=
  match e__6 with
  | (exprVar x) => (true)
  | (exprApp e5 e') => false
  | (exprCApp CtorName5 EnumName5 e5) => false
  | (exprmatch e_5 CtorName1 EnumName5 x1 e1 CtorName2 EnumName' x2 e2) => false
  | (exprLet x e5 e') => false
  | (exprAssign lv5 e') => false
  | (exprSeq e5 e') => false
  | (exprRef lv5) => false
  | (exprDeref e5) => ((is_e_of_e e5))
  | exprUnit => false
  | (exprTuple e5 e') => false
  | (exprfst e5) => false
  | (exprsnd e5) => false
  | (exprAnnot e5 T5) => false
  | (exprStructInit SName5 x1 e1 x2 e2) => false
  | (exprStructField e5 x) => ((is_lv_of_e e5))
  | (exprInternal internal5) => ((is_internallv_of_internal internal5))
end
with is_tau_of_T (T_6:T) : bool :=
  match T_6 with
  | (T_var X5) => (true)
  | (T_polyarrow X_list pi5 T5 T') => false
  | (T_TyApp T5 tau5) => ((is_tau_of_T T5) && (is_tau_of_T tau5))
  | (T_Tuple T5 T') => ((is_tau_of_T T5) && (is_tau_of_T T'))
  | (T_StructType SName5) => (true)
  | (T_EnumType EnumName5) => (true)
  | T_UType => (true)
  | (T_RefType T5) => ((is_tau_of_T T5))
  | (T_TraitObj X5 beta5) => ((is_beta_of_beta beta5))
  | (T_Assoc X5 beta5) => ((is_beta_of_beta beta5))
  | (T_unifVar alpha5) => (true)
end.

Definition is_fundecl_of_fundecl (fundecl5:fundecl) : bool :=
  match fundecl5 with
  | (fundecl_fundecl f X_list x T1 T2 pi5) => ((forall_list (fun (X_:X) => true) X_list) && (is_T_of_T T1) && (is_T_of_T T2) && (is_pi_of_pi pi5))
end.

Definition is_fundef_of_fundef (fundef5:fundef) : bool :=
  match fundef5 with
  | (fundef_fundef f X_list x T1 T2 pi5 e5) => ((forall_list (fun (X_:X) => true) X_list) && (is_T_of_T T1) && (is_T_of_T T2) && (is_pi_of_pi pi5) && (is_e_of_e e5))
end.

Definition is_item_of_item (item5:item) : bool :=
  match item5 with
  | (itemstruct SName5 X_list x1 T1 x2 T2) => ((forall_list (fun (X_:X) => true) X_list) && (is_T_of_T T1) && (is_T_of_T T2))
  | (itemenum EnumName5 X_list CtorName1 T1 CtorName2 T2) => ((forall_list (fun (X_:X) => true) X_list) && (is_T_of_T T1) && (is_T_of_T T2))
  | (itemtraitdecl D5 X_list pi5 X' fundecl5) => ((forall_list (fun (X_:X) => true) X_list) && (is_pi_of_pi pi5) && (is_fundecl_of_fundecl fundecl5))
  | (itemtraitimpl X_list D5 tau_list T5 pi5 X' T' fundef5) => ((forall_list (fun (X_:X) => true) X_list) && (forall_list (fun (tau_:T) => (is_tau_of_T tau_)) tau_list) && (is_T_of_T T5) && (is_pi_of_pi pi5) && (is_T_of_T T') && (is_fundef_of_fundef fundef5))
  | (itemfundef fundef5) => ((is_fundef_of_fundef fundef5))
end.

Fixpoint is_CC_of_CC (CC_6:CC) : bool :=
  match CC_6 with
  | coercionContext_empty => (true)
  | (coercionContext_spec tau_list) => ((forall_list (fun (tau_:T) => (is_tau_of_T tau_)) tau_list))
  | (coercionContext_obj X5 beta5 T2 f v5) => ((is_beta_of_beta beta5) && (is_T_of_T T2) && (is_v_of_e v5))
  | (coercionContext_gen X_list CC5) => ((forall_list (fun (X_:X) => true) X_list) && (is_CC_of_CC CC5))
end.

Definition is_gamma_of_gamma (gamma_6:gamma) : bool :=
  match gamma_6 with
  | (gamma_evar x T5) => ((is_T_of_T T5))
  | (gamma_tvar X5) => (true)
end.

Definition is_pretty_of_pretty (pretty5:pretty) : bool :=
  match pretty5 with
  | (prettytseq T_list) => ((forall_list (fun (T_:T) => (is_T_of_T T_)) T_list))
end.

Definition is_kinded_of_kinded (kinded5:kinded) : bool :=
  match kinded5 with
  | (kinded_type T5) => ((is_T_of_T T5))
  | (kinded_constr pi5) => ((is_pi_of_pi pi5))
  | (kinded_impl beta5) => ((is_beta_of_beta beta5))
end.

Definition is_prob_of_prob (prob_6:prob) : bool :=
  match prob_6 with
  | (problemsEq Gamma5 Theta5 T1 T2) => ((is_T_of_T T1) && (is_T_of_T T2))
  | (problemsSub Gamma5 Theta5 T1 T2) => ((is_T_of_T T1) && (is_T_of_T T2))
  | (problemsEntails Gamma5 Theta5 pi5) => ((is_pi_of_pi pi5))
  | (problemsKind Gamma5 Theta5 T5 K5) => ((is_T_of_T T5))
end.

Definition is_EC_of_EC (EC5:EC) : bool :=
  match EC5 with
  | (evalContextApp1 e5) => ((is_e_of_e e5))
  | (evalContextApp2 v5) => ((is_v_of_e v5))
  | (evalContextCApp CtorName5 EnumName5) => (true)
  | (evalContextmatch CtorName1 EnumName5 x1 e1 CtorName2 EnumName' x2 e2) => ((is_e_of_e e1) && (is_e_of_e e2))
  | evalContextfst => (true)
  | evalContextsnd => (true)
  | (evalContextLet x e') => ((is_e_of_e e'))
  | (evalContextAssign lv5) => ((is_lv_of_e lv5))
  | (evalContextSeq e5) => ((is_e_of_e e5))
  | evalContextDeref => (true)
  | (evalContextTuple1 e') => ((is_e_of_e e'))
  | (evalContextTuple2 v5) => ((is_v_of_e v5))
  | (evalContextAnnot T5) => ((is_T_of_T T5))
  | (evalContextStructInit1 SName5 x1 x2 e2) => ((is_e_of_e e2))
  | (evalContextStructInit SName5 x1 v5 x2) => ((is_v_of_e v5))
  | (evalContextStructField x) => (true)
  | (evalContextobjapp1 f e2) => ((is_e_of_e e2))
  | (evalContextobjapp2 v5 f) => ((is_v_of_e v5))
end.

Definition is_theta_of_theta (theta_6:theta) : bool :=
  match theta_6 with
  | (theta_pi pi5) => ((is_pi_of_pi pi5))
  | (theta_fnval f e5) => ((is_e_of_e e5))
  | (theta_item item5) => ((is_item_of_item item5))
end.

Definition is_XD_of_XD (XD5:XD) : bool :=
  match XD5 with
  | (assocType_name X5 beta5) => ((is_beta_of_beta beta5))
end.


(** context application *)
Fixpoint appctx_CC_e (CC_6:CC) (e5:e) : e :=
  match CC_6 with
  | coercionContext_empty => e5
  | (coercionContext_spec tau_list) => (exprInternal (internalspec e5 tau_list))
  | (coercionContext_obj X5 beta5 T2 f v5) => (exprInternal (internalobj X5 beta5 e5 T2 f v5))
  | (coercionContext_gen X_list CC5) => (exprInternal (internalgen X_list  (appctx_CC_expr  CC5   e5 ) ))
end.

Fixpoint appctx_EC_e (EC5:EC) (e_6:e) : e :=
  match EC5 with
  | (evalContextApp1 e5) => (exprApp e_6 e5)
  | (evalContextApp2 v5) => (exprApp v5 e_6)
  | (evalContextCApp CtorName5 EnumName5) => (exprCApp CtorName5 EnumName5 e_6)
  | (evalContextmatch CtorName1 EnumName5 x1 e1 CtorName2 EnumName' x2 e2) => (exprmatch e_6 CtorName1 EnumName5 x1 e1 CtorName2 EnumName' x2 e2)
  | evalContextfst => (exprfst e_6)
  | evalContextsnd => (exprsnd e_6)
  | (evalContextLet x e') => (exprLet x e_6 e')
  | (evalContextAssign lv5) => (exprAssign lv5 e_6)
  | (evalContextSeq e5) => (exprSeq e_6 e5)
  | evalContextDeref => (exprDeref e_6)
  | (evalContextTuple1 e') => (exprTuple e_6 e')
  | (evalContextTuple2 v5) => (exprTuple v5 e_6)
  | (evalContextAnnot T5) => (exprAnnot e_6 T5)
  | (evalContextStructInit1 SName5 x1 x2 e2) => (exprStructInit SName5 x1 e_6 x2 e2)
  | (evalContextStructInit SName5 x1 v5 x2) => (exprStructInit SName5 x1 v5 x2 e_6)
  | (evalContextStructField x) => (exprStructField e_6 x)
  | (evalContextobjapp1 f e2) => (exprInternal (internalobjapp e_6 f e2))
  | (evalContextobjapp2 v5 f) => (exprInternal (internalobjapp v5 f e_6))
end.

(** library functions *)
Fixpoint list_mem A (eq:forall a b:A,{a=b}+{a<>b}) (x:A) (l:list A) {struct l} : bool :=
  match l with
  | nil => false
  | cons h t => if eq h x then true else list_mem A eq x t
end.
Arguments list_mem [A] _ _ _.

Fixpoint list_assoc A B (eq:forall a b:A,{a=b}+{a<>b}) (x:A) (l:list (A*B)) {struct l} : option B :=
  match l with
  | nil => None
  | cons (a,b) t => if (eq a x) then Some b else list_assoc A B eq x t
end.
Arguments list_assoc [A B] _ _ _.


(** substitutions *)
Fixpoint tsubst_beta (sub:list (X*T)) (beta_6:beta) {struct beta_6} : beta :=
  match beta_6 with
  | (beta_TraitName D5) => beta_TraitName D5
  | (beta_TypeApp beta5 tau5) => beta_TypeApp (tsubst_beta sub beta5) tau5
  | (beta_Assoc beta5 X5 tau5) => beta_Assoc (tsubst_beta sub beta5) X5 tau5
  | (beta_elab beta5 f e5) => beta_elab (tsubst_beta sub beta5) f (tsubst_e sub e5)
end
with tsubst_pi (sub:list (X*T)) (pi_6:pi) {struct pi_6} : pi :=
  match pi_6 with
  | (pi_trtBound tau5 beta5) => pi_trtBound tau5 (tsubst_beta sub beta5)
  | (pi_forall X_list pi5 tau5 beta5) => pi_forall X_list (tsubst_pi sub pi5) tau5 (tsubst_beta sub beta5)
  | (pi_conj pi1 pi2) => pi_conj (tsubst_pi sub pi1) (tsubst_pi sub pi2)
  | pi_empty => pi_empty 
end
with tsubst_T (sub:list (X*T)) (T__7:T) {struct T__7} : T :=
  match T__7 with
  | (T_var X5) => (match list_assoc eq_X X5 sub with None => (T_var X5) | Some T_6 => T_6 end)
  | (T_polyarrow X_list pi5 T5 T') => T_polyarrow X_list (tsubst_pi sub pi5) (tsubst_T sub T5) (tsubst_T sub T')
  | (T_TyApp T5 tau5) => T_TyApp (tsubst_T sub T5) tau5
  | (T_Tuple T5 T') => T_Tuple (tsubst_T sub T5) (tsubst_T sub T')
  | (T_StructType SName5) => T_StructType SName5
  | (T_EnumType EnumName5) => T_EnumType EnumName5
  | T_UType => T_UType 
  | (T_RefType T5) => T_RefType (tsubst_T sub T5)
  | (T_TraitObj X5 beta5) => T_TraitObj X5 (tsubst_beta sub beta5)
  | (T_Assoc X5 beta5) => T_Assoc X5 (tsubst_beta sub beta5)
  | (T_unifVar alpha5) => T_unifVar alpha5
end
with tsubst_internal (sub:list (X*T)) (internal5:internal) {struct internal5} : internal :=
  match internal5 with
  | (internalRawProc x T1 e5 T2) => internalRawProc x (tsubst_T sub T1) (tsubst_e sub e5) (tsubst_T sub T2)
  | (internalobj X5 beta5 e5 T2 f v5) => internalobj X5 (tsubst_beta sub beta5) (tsubst_e sub e5) (tsubst_T sub T2) f v5
  | (internalobjapp e1 f e2) => internalobjapp (tsubst_e sub e1) f (tsubst_e sub e2)
  | (internalspec e5 tau_list) => internalspec (tsubst_e sub e5) tau_list
  | (internalgen X_list e5) => internalgen X_list (tsubst_e sub e5)
  | (internalloc loc5) => internalloc loc5
end
with tsubst_e (sub:list (X*T)) (e__6:e) {struct e__6} : e :=
  match e__6 with
  | (exprVar x) => exprVar x
  | (exprApp e5 e') => exprApp (tsubst_e sub e5) (tsubst_e sub e')
  | (exprCApp CtorName5 EnumName5 e5) => exprCApp CtorName5 EnumName5 (tsubst_e sub e5)
  | (exprmatch e_5 CtorName1 EnumName5 x1 e1 CtorName2 EnumName' x2 e2) => exprmatch (tsubst_e sub e_5) CtorName1 EnumName5 x1 (tsubst_e sub e1) CtorName2 EnumName' x2 (tsubst_e sub e2)
  | (exprLet x e5 e') => exprLet x (tsubst_e sub e5) (tsubst_e sub e')
  | (exprAssign lv5 e') => exprAssign lv5 (tsubst_e sub e')
  | (exprSeq e5 e') => exprSeq (tsubst_e sub e5) (tsubst_e sub e')
  | (exprRef lv5) => exprRef lv5
  | (exprDeref e5) => exprDeref (tsubst_e sub e5)
  | exprUnit => exprUnit 
  | (exprTuple e5 e') => exprTuple (tsubst_e sub e5) (tsubst_e sub e')
  | (exprfst e5) => exprfst (tsubst_e sub e5)
  | (exprsnd e5) => exprsnd (tsubst_e sub e5)
  | (exprAnnot e5 T5) => exprAnnot (tsubst_e sub e5) (tsubst_T sub T5)
  | (exprStructInit SName5 x1 e1 x2 e2) => exprStructInit SName5 x1 (tsubst_e sub e1) x2 (tsubst_e sub e2)
  | (exprStructField e5 x) => exprStructField (tsubst_e sub e5) x
  | (exprInternal internal5) => exprInternal (tsubst_internal sub internal5)
end.

Fixpoint esubst_internal (e_6:e) (x5:exprvar) (internal5:internal) {struct internal5} : internal :=
  match internal5 with
  | (internalRawProc x T1 e5 T2) => internalRawProc x (esubst_T e_6 x5 T1) (esubst_e e_6 x5 e5) (esubst_T e_6 x5 T2)
  | (internalobj X5 beta5 e5 T2 f v5) => internalobj X5 (esubst_beta e_6 x5 beta5) (esubst_e e_6 x5 e5) (esubst_T e_6 x5 T2) f v5
  | (internalobjapp e1 f e2) => internalobjapp (esubst_e e_6 x5 e1) f (esubst_e e_6 x5 e2)
  | (internalspec e5 tau_list) => internalspec (esubst_e e_6 x5 e5) tau_list
  | (internalgen X_list e5) => internalgen X_list (esubst_e e_6 x5 e5)
  | (internalloc loc5) => internalloc loc5
end
with esubst_e (e__6:e) (x_5:exprvar) (e___7:e) {struct e___7} : e :=
  match e___7 with
  | (exprVar x) => (if eq_exprvar x x_5 then e__6 else (exprVar x))
  | (exprApp e5 e') => exprApp (esubst_e e__6 x_5 e5) (esubst_e e__6 x_5 e')
  | (exprCApp CtorName5 EnumName5 e5) => exprCApp CtorName5 EnumName5 (esubst_e e__6 x_5 e5)
  | (exprmatch e_5 CtorName1 EnumName5 x1 e1 CtorName2 EnumName' x2 e2) => exprmatch (esubst_e e__6 x_5 e_5) CtorName1 EnumName5 x1 (esubst_e e__6 x_5 e1) CtorName2 EnumName' x2 (esubst_e e__6 x_5 e2)
  | (exprLet x e5 e') => exprLet x (esubst_e e__6 x_5 e5) (if list_mem eq_exprvar x_5 (cons x nil) then e' else (esubst_e e__6 x_5 e'))
  | (exprAssign lv5 e') => exprAssign lv5 (esubst_e e__6 x_5 e')
  | (exprSeq e5 e') => exprSeq (esubst_e e__6 x_5 e5) (esubst_e e__6 x_5 e')
  | (exprRef lv5) => exprRef lv5
  | (exprDeref e5) => exprDeref (esubst_e e__6 x_5 e5)
  | exprUnit => exprUnit 
  | (exprTuple e5 e') => exprTuple (esubst_e e__6 x_5 e5) (esubst_e e__6 x_5 e')
  | (exprfst e5) => exprfst (esubst_e e__6 x_5 e5)
  | (exprsnd e5) => exprsnd (esubst_e e__6 x_5 e5)
  | (exprAnnot e5 T5) => exprAnnot (esubst_e e__6 x_5 e5) (esubst_T e__6 x_5 T5)
  | (exprStructInit SName5 x1 e1 x2 e2) => exprStructInit SName5 x1 (esubst_e e__6 x_5 e1) x2 (esubst_e e__6 x_5 e2)
  | (exprStructField e5 x) => exprStructField (esubst_e e__6 x_5 e5) x
  | (exprInternal internal5) => exprInternal (esubst_internal e__6 x_5 internal5)
end
with esubst_beta (e_6:e) (x5:exprvar) (beta_6:beta) {struct beta_6} : beta :=
  match beta_6 with
  | (beta_TraitName D5) => beta_TraitName D5
  | (beta_TypeApp beta5 tau5) => beta_TypeApp (esubst_beta e_6 x5 beta5) tau5
  | (beta_Assoc beta5 X5 tau5) => beta_Assoc (esubst_beta e_6 x5 beta5) X5 tau5
  | (beta_elab beta5 f e5) => beta_elab (esubst_beta e_6 x5 beta5) f (esubst_e e_6 x5 e5)
end
with esubst_pi (e5:e) (x5:exprvar) (pi_6:pi) {struct pi_6} : pi :=
  match pi_6 with
  | (pi_trtBound tau5 beta5) => pi_trtBound tau5 (esubst_beta e5 x5 beta5)
  | (pi_forall X_list pi5 tau5 beta5) => pi_forall X_list (esubst_pi e5 x5 pi5) tau5 (esubst_beta e5 x5 beta5)
  | (pi_conj pi1 pi2) => pi_conj (esubst_pi e5 x5 pi1) (esubst_pi e5 x5 pi2)
  | pi_empty => pi_empty 
end
with esubst_T (e5:e) (x5:exprvar) (T_6:T) {struct T_6} : T :=
  match T_6 with
  | (T_var X5) => T_var X5
  | (T_polyarrow X_list pi5 T5 T') => T_polyarrow X_list (esubst_pi e5 x5 pi5) (esubst_T e5 x5 T5) (esubst_T e5 x5 T')
  | (T_TyApp T5 tau5) => T_TyApp (esubst_T e5 x5 T5) tau5
  | (T_Tuple T5 T') => T_Tuple (esubst_T e5 x5 T5) (esubst_T e5 x5 T')
  | (T_StructType SName5) => T_StructType SName5
  | (T_EnumType EnumName5) => T_EnumType EnumName5
  | T_UType => T_UType 
  | (T_RefType T5) => T_RefType (esubst_T e5 x5 T5)
  | (T_TraitObj X5 beta5) => T_TraitObj X5 (esubst_beta e5 x5 beta5)
  | (T_Assoc X5 beta5) => T_Assoc X5 (esubst_beta e5 x5 beta5)
  | (T_unifVar alpha5) => T_unifVar alpha5
end.

Definition tsubst_fundecl (sub:list (X*T)) (fundecl5:fundecl) : fundecl :=
  match fundecl5 with
  | (fundecl_fundecl f X_list x T1 T2 pi5) => fundecl_fundecl f X_list x (tsubst_T sub T1) (tsubst_T sub T2) (tsubst_pi sub pi5)
end.

Definition tsubst_fundef (sub:list (X*T)) (fundef5:fundef) : fundef :=
  match fundef5 with
  | (fundef_fundef f X_list x T1 T2 pi5 e5) => fundef_fundef f X_list x (tsubst_T sub T1) (tsubst_T sub T2) (tsubst_pi sub pi5) (tsubst_e sub e5)
end.

Definition esubst_fundef (e_6:e) (x5:exprvar) (fundef5:fundef) : fundef :=
  match fundef5 with
  | (fundef_fundef f X_list x T1 T2 pi5 e5) => fundef_fundef f X_list x (esubst_T e_6 x5 T1) (esubst_T e_6 x5 T2) (esubst_pi e_6 x5 pi5) (esubst_e e_6 x5 e5)
end.

Definition esubst_fundecl (e5:e) (x5:exprvar) (fundecl5:fundecl) : fundecl :=
  match fundecl5 with
  | (fundecl_fundecl f X_list x T1 T2 pi5) => fundecl_fundecl f X_list x (esubst_T e5 x5 T1) (esubst_T e5 x5 T2) (esubst_pi e5 x5 pi5)
end.

Definition tsubst_item (sub:list (X*T)) (item5:item) : item :=
  match item5 with
  | (itemstruct SName5 X_list x1 T1 x2 T2) => itemstruct SName5 X_list x1 (tsubst_T sub T1) x2 (tsubst_T sub T2)
  | (itemenum EnumName5 X_list CtorName1 T1 CtorName2 T2) => itemenum EnumName5 X_list CtorName1 (tsubst_T sub T1) CtorName2 (tsubst_T sub T2)
  | (itemtraitdecl D5 X_list pi5 X' fundecl5) => itemtraitdecl D5 X_list (tsubst_pi sub pi5) X' (tsubst_fundecl sub fundecl5)
  | (itemtraitimpl X_list D5 tau_list T5 pi5 X' T' fundef5) => itemtraitimpl X_list D5 tau_list (tsubst_T sub T5) (tsubst_pi sub pi5) X' (tsubst_T sub T') (tsubst_fundef sub fundef5)
  | (itemfundef fundef5) => itemfundef (tsubst_fundef sub fundef5)
end.

Definition esubst_prob (e5:e) (x5:exprvar) (prob_6:prob) : prob :=
  match prob_6 with
  | (problemsEq Gamma5 Theta5 T1 T2) => problemsEq Gamma5 Theta5 (esubst_T e5 x5 T1) (esubst_T e5 x5 T2)
  | (problemsSub Gamma5 Theta5 T1 T2) => problemsSub Gamma5 Theta5 (esubst_T e5 x5 T1) (esubst_T e5 x5 T2)
  | (problemsEntails Gamma5 Theta5 pi5) => problemsEntails Gamma5 Theta5 (esubst_pi e5 x5 pi5)
  | (problemsKind Gamma5 Theta5 T5 K5) => problemsKind Gamma5 Theta5 (esubst_T e5 x5 T5) K5
end.

Definition tsubst_prob (sub:list (X*T)) (prob_6:prob) : prob :=
  match prob_6 with
  | (problemsEq Gamma5 Theta5 T1 T2) => problemsEq Gamma5 Theta5 (tsubst_T sub T1) (tsubst_T sub T2)
  | (problemsSub Gamma5 Theta5 T1 T2) => problemsSub Gamma5 Theta5 (tsubst_T sub T1) (tsubst_T sub T2)
  | (problemsEntails Gamma5 Theta5 pi5) => problemsEntails Gamma5 Theta5 (tsubst_pi sub pi5)
  | (problemsKind Gamma5 Theta5 T5 K5) => problemsKind Gamma5 Theta5 (tsubst_T sub T5) K5
end.

Definition esubst_item (e5:e) (x_5:exprvar) (item5:item) : item :=
  match item5 with
  | (itemstruct SName5 X_list x1 T1 x2 T2) => itemstruct SName5 X_list x1 (esubst_T e5 x_5 T1) x2 (esubst_T e5 x_5 T2)
  | (itemenum EnumName5 X_list CtorName1 T1 CtorName2 T2) => itemenum EnumName5 X_list CtorName1 (esubst_T e5 x_5 T1) CtorName2 (esubst_T e5 x_5 T2)
  | (itemtraitdecl D5 X_list pi5 X' fundecl5) => itemtraitdecl D5 X_list (esubst_pi e5 x_5 pi5) X' (esubst_fundecl e5 x_5 fundecl5)
  | (itemtraitimpl X_list D5 tau_list T5 pi5 X' T' fundef5) => itemtraitimpl X_list D5 tau_list (esubst_T e5 x_5 T5) (esubst_pi e5 x_5 pi5) X' (esubst_T e5 x_5 T') (esubst_fundef e5 x_5 fundef5)
  | (itemfundef fundef5) => itemfundef (esubst_fundef e5 x_5 fundef5)
end.

Definition esubst_EC (e_6:e) (x_5:exprvar) (EC5:EC) : EC :=
  match EC5 with
  | (evalContextApp1 e5) => evalContextApp1 (esubst_e e_6 x_5 e5)
  | (evalContextApp2 v5) => evalContextApp2 v5
  | (evalContextCApp CtorName5 EnumName5) => evalContextCApp CtorName5 EnumName5
  | (evalContextmatch CtorName1 EnumName5 x1 e1 CtorName2 EnumName' x2 e2) => evalContextmatch CtorName1 EnumName5 x1 (esubst_e e_6 x_5 e1) CtorName2 EnumName' x2 (esubst_e e_6 x_5 e2)
  | evalContextfst => evalContextfst 
  | evalContextsnd => evalContextsnd 
  | (evalContextLet x e') => evalContextLet x (if list_mem eq_exprvar x_5 (cons x nil) then e' else (esubst_e e_6 x_5 e'))
  | (evalContextAssign lv5) => evalContextAssign lv5
  | (evalContextSeq e5) => evalContextSeq (esubst_e e_6 x_5 e5)
  | evalContextDeref => evalContextDeref 
  | (evalContextTuple1 e') => evalContextTuple1 (esubst_e e_6 x_5 e')
  | (evalContextTuple2 v5) => evalContextTuple2 v5
  | (evalContextAnnot T5) => evalContextAnnot (esubst_T e_6 x_5 T5)
  | (evalContextStructInit1 SName5 x1 x2 e2) => evalContextStructInit1 SName5 x1 x2 (esubst_e e_6 x_5 e2)
  | (evalContextStructInit SName5 x1 v5 x2) => evalContextStructInit SName5 x1 v5 x2
  | (evalContextStructField x) => evalContextStructField x
  | (evalContextobjapp1 f e2) => evalContextobjapp1 f (esubst_e e_6 x_5 e2)
  | (evalContextobjapp2 v5 f) => evalContextobjapp2 v5 f
end.

Definition tsubst_EC (sub:list (X*T)) (EC5:EC) : EC :=
  match EC5 with
  | (evalContextApp1 e5) => evalContextApp1 (tsubst_e sub e5)
  | (evalContextApp2 v5) => evalContextApp2 v5
  | (evalContextCApp CtorName5 EnumName5) => evalContextCApp CtorName5 EnumName5
  | (evalContextmatch CtorName1 EnumName5 x1 e1 CtorName2 EnumName' x2 e2) => evalContextmatch CtorName1 EnumName5 x1 (tsubst_e sub e1) CtorName2 EnumName' x2 (tsubst_e sub e2)
  | evalContextfst => evalContextfst 
  | evalContextsnd => evalContextsnd 
  | (evalContextLet x e') => evalContextLet x (tsubst_e sub e')
  | (evalContextAssign lv5) => evalContextAssign lv5
  | (evalContextSeq e5) => evalContextSeq (tsubst_e sub e5)
  | evalContextDeref => evalContextDeref 
  | (evalContextTuple1 e') => evalContextTuple1 (tsubst_e sub e')
  | (evalContextTuple2 v5) => evalContextTuple2 v5
  | (evalContextAnnot T5) => evalContextAnnot (tsubst_T sub T5)
  | (evalContextStructInit1 SName5 x1 x2 e2) => evalContextStructInit1 SName5 x1 x2 (tsubst_e sub e2)
  | (evalContextStructInit SName5 x1 v5 x2) => evalContextStructInit SName5 x1 v5 x2
  | (evalContextStructField x) => evalContextStructField x
  | (evalContextobjapp1 f e2) => evalContextobjapp1 f (tsubst_e sub e2)
  | (evalContextobjapp2 v5 f) => evalContextobjapp2 v5 f
end.

Definition tsubst_pretty (sub:list (X*T)) (pretty5:pretty) : pretty :=
  match pretty5 with
  | (prettytseq T_list) => prettytseq (map (fun (T_:T) => (tsubst_T sub T_)) T_list)
end.

Definition tsubst_theta (sub:list (X*T)) (theta_6:theta) : theta :=
  match theta_6 with
  | (theta_pi pi5) => theta_pi (tsubst_pi sub pi5)
  | (theta_fnval f e5) => theta_fnval f (tsubst_e sub e5)
  | (theta_item item5) => theta_item (tsubst_item sub item5)
end.

Fixpoint esubst_P (e5:e) (x5:exprvar) (P_6:P) {struct P_6} : P :=
  match P_6 with
  | (probListSeq prob_list) => probListSeq (map (fun (prob_:prob) => (esubst_prob e5 x5 prob_)) prob_list)
  | (probListLiteral prob_list) => probListLiteral (map (fun (prob_:prob) => (esubst_prob e5 x5 prob_)) prob_list)
  | (probListUnion P1 P2) => probListUnion (esubst_P e5 x5 P1) (esubst_P e5 x5 P2)
end.

Fixpoint tsubst_CC (sub:list (X*T)) (CC_6:CC) {struct CC_6} : CC :=
  match CC_6 with
  | coercionContext_empty => coercionContext_empty 
  | (coercionContext_spec tau_list) => coercionContext_spec tau_list
  | (coercionContext_obj X5 beta5 T2 f v5) => coercionContext_obj X5 (tsubst_beta sub beta5) (tsubst_T sub T2) f v5
  | (coercionContext_gen X_list CC5) => coercionContext_gen X_list (tsubst_CC sub CC5)
end.

Fixpoint esubst_CC (e5:e) (x5:exprvar) (CC_6:CC) {struct CC_6} : CC :=
  match CC_6 with
  | coercionContext_empty => coercionContext_empty 
  | (coercionContext_spec tau_list) => coercionContext_spec tau_list
  | (coercionContext_obj X5 beta5 T2 f v5) => coercionContext_obj X5 (esubst_beta e5 x5 beta5) (esubst_T e5 x5 T2) f v5
  | (coercionContext_gen X_list CC5) => coercionContext_gen X_list (esubst_CC e5 x5 CC5)
end.

Definition esubst_kinded (e5:e) (x5:exprvar) (kinded5:kinded) : kinded :=
  match kinded5 with
  | (kinded_type T5) => kinded_type (esubst_T e5 x5 T5)
  | (kinded_constr pi5) => kinded_constr (esubst_pi e5 x5 pi5)
  | (kinded_impl beta5) => kinded_impl (esubst_beta e5 x5 beta5)
end.

Fixpoint tsubst_P (sub:list (X*T)) (P_6:P) {struct P_6} : P :=
  match P_6 with
  | (probListSeq prob_list) => probListSeq (map (fun (prob_:prob) => (tsubst_prob sub prob_)) prob_list)
  | (probListLiteral prob_list) => probListLiteral (map (fun (prob_:prob) => (tsubst_prob sub prob_)) prob_list)
  | (probListUnion P1 P2) => probListUnion (tsubst_P sub P1) (tsubst_P sub P2)
end.

Definition tsubst_XD (sub:list (X*T)) (XD5:XD) : XD :=
  match XD5 with
  | (assocType_name X5 beta5) => assocType_name X5 (tsubst_beta sub beta5)
end.

Definition esubst_pretty (e5:e) (x5:exprvar) (pretty5:pretty) : pretty :=
  match pretty5 with
  | (prettytseq T_list) => prettytseq (map (fun (T_:T) => (esubst_T e5 x5 T_)) T_list)
end.

Definition tsubst_gamma (sub:list (X*T)) (gamma_6:gamma) : gamma :=
  match gamma_6 with
  | (gamma_evar x T5) => gamma_evar x (tsubst_T sub T5)
  | (gamma_tvar X5) => gamma_tvar X5
end.

Definition esubst_XD (e5:e) (x5:exprvar) (XD5:XD) : XD :=
  match XD5 with
  | (assocType_name X5 beta5) => assocType_name X5 (esubst_beta e5 x5 beta5)
end.

Definition esubst_gamma (e5:e) (x5:exprvar) (gamma_6:gamma) : gamma :=
  match gamma_6 with
  | (gamma_evar x T5) => gamma_evar x (esubst_T e5 x5 T5)
  | (gamma_tvar X5) => gamma_tvar X5
end.

Definition tsubst_kinded (sub:list (X*T)) (kinded5:kinded) : kinded :=
  match kinded5 with
  | (kinded_type T5) => kinded_type (tsubst_T sub T5)
  | (kinded_constr pi5) => kinded_constr (tsubst_pi sub pi5)
  | (kinded_impl beta5) => kinded_impl (tsubst_beta sub beta5)
end.

Definition esubst_theta (e_6:e) (x5:exprvar) (theta_6:theta) : theta :=
  match theta_6 with
  | (theta_pi pi5) => theta_pi (esubst_pi e_6 x5 pi5)
  | (theta_fnval f e5) => theta_fnval f (esubst_e e_6 x5 e5)
  | (theta_item item5) => theta_item (esubst_item e_6 x5 item5)
end.

Instance Map_Delta : Map termvar loc Delta.
apply (Map_alist RelDec_eq). 
Defined.

Instance Map_sigma : Map loc expr sigma.
apply (Map_alist RelDec_eq). 
Defined.

(** definitions *)

(* defns Jtype *)
Inductive entail : Gamma -> Theta -> pi -> Prop :=    (* defn entail *)
 | EntailInst : forall (X_tau_tau_list:list (X*T*T)) (Gamma5:Gamma) (Theta5:Theta) (tau_5:T) (beta5:beta) (pi5:pi),
     Is_true (is_tau_of_T tau_5) ->
     Is_true (is_beta_of_beta beta5) ->
     Is_true (is_pi_of_pi pi5) ->
     (Forall (fun (tmp_:(X*T*T)) => match tmp_ with (X_,tau_,_) => Is_true (is_tau_of_T tau_) end) X_tau_tau_list) ->
     (Forall (fun (tmp_:(X*T*T)) => match tmp_ with (X_,tau_,_) => Is_true (is_tau_of_T tau_) end) X_tau_tau_list) ->
      (Exists_list (fun p => p =  (theta_pi (pi_forall (map (fun (pat_:(X*T*T)) => match pat_ with (X_,tau_,_) => X_ end ) X_tau_tau_list) pi5 tau_5 beta5)) )  Theta5 )  ->
     (forall tau_ X_, In (tau_,X_) (map (fun (pat_: (X*T*T)) => match pat_ with (X_,tau_,_) => (tau_,X_) end) X_tau_tau_list) -> (HasKind Gamma5 Theta5 (kinded_type tau_)  (kindOf X_ ) )) ->
     entail Gamma5 Theta5  (tsubst_pi  (map (fun (pat_:(X*T*T)) => match pat_ with (X_,tau_,_) => (X_,tau_) end ) X_tau_tau_list)   pi5 )  ->
     entail Gamma5 Theta5  (tsubst_pi  (map (fun (pat_:(X*T*T)) => match pat_ with (X_,tau_,_) => (X_,tau_) end ) X_tau_tau_list)    ( (pi_trtBound tau_5 beta5) )  ) 
 | EntailSkolem : forall (X_X'_list:list (X*X)) (Gamma5:Gamma) (Theta5:Theta) (pi5:pi) (tau5:T) (beta5:beta),
     Is_true (is_pi_of_pi pi5) ->
     Is_true (is_tau_of_T tau5) ->
     Is_true (is_beta_of_beta beta5) ->
     entail Gamma5  (  (cons (theta_pi pi5) nil)  ++  Theta5  )   (tsubst_pi  (map (fun (pat_:(X*X)) => match pat_ with (X_,X'_) => (X_,(T_var X'_)) end ) X_X'_list)    ( (pi_trtBound tau5 beta5) )  )  ->
     (forall X'_, In (X'_) (map (fun (pat_: (X*X)) => match pat_ with (X_,X'_) => (X'_) end) X_X'_list) ->  ( false =  (list_mem eq_gamma (gamma_tvar  X'_  )  Gamma5 ) ) ) ->
     entail Gamma5 Theta5 (pi_forall (map (fun (pat_:(X*X)) => match pat_ with (X_,X'_) => X_ end ) X_X'_list) pi5 tau5 beta5)
 | EntailTrue : forall (Gamma5:Gamma) (Theta5:Theta),
     entail Gamma5 Theta5 pi_empty
 | EntailConj : forall (Gamma5:Gamma) (Theta5:Theta) (pi1 pi2:pi),
     Is_true (is_pi_of_pi pi1) ->
     Is_true (is_pi_of_pi pi2) ->
     entail Gamma5 Theta5 pi1 ->
     entail Gamma5 Theta5 pi2 ->
     entail Gamma5 Theta5 (pi_conj pi1 pi2)
 | EntailForgetAssoc : forall (tau_list:list T) (Gamma5:Gamma) (Theta5:Theta) (tau_5:T) (D5:D) (X5:X),
     Is_true (is_tau_of_T tau_5) ->
     (Forall (fun (tau_:T) => Is_true (is_tau_of_T tau_)) tau_list) ->
     entail Gamma5 Theta5 (pi_trtBound tau_5  (fold_right (fun tau accum => beta_TypeApp accum tau ) 
    (fold_right 
      (fun pair accum => beta_Assoc accum (fst pair) (snd pair) )
      (beta_TraitName  D5 )
      (  X5   )  tau_5  
    ) 
     tau_list ) ) ->
     entail Gamma5 Theta5 (pi_trtBound tau_5  TODOsugar1 )
 | EntailForgetElab : forall (Gamma5:Gamma) (Theta5:Theta) (tau5:T) (beta5:beta) (f:exprvar) (e5:e),
     Is_true (is_tau_of_T tau5) ->
     Is_true (is_beta_of_beta beta5) ->
     Is_true (is_e_of_e e5) ->
     entail Gamma5 Theta5 (pi_trtBound tau5 (beta_elab beta5 f e5)) ->
     entail Gamma5 Theta5 (pi_trtBound tau5 beta5)
with HasKind : Gamma -> Theta -> kinded -> K -> Prop :=    (* defn HasKind *)
 | HasKindVar : forall (Gamma5:Gamma) (Theta5:Theta) (X5:X),
      (Exists_list (fun g => g =  (gamma_tvar X5)  )  Gamma5 )  ->
     HasKind Gamma5 Theta5 (kinded_type (T_var X5))  (kindOf X5 ) 
 | HasKindUnit : forall (Gamma5:Gamma) (Theta5:Theta),
     HasKind Gamma5 Theta5 (kinded_type T_UType) kind_KindStar
 | HasKindRef : forall (Gamma5:Gamma) (Theta5:Theta) (T5:T),
     Is_true (is_T_of_T T5) ->
     HasKind Gamma5 Theta5 (kinded_type T5) kind_KindStar ->
     HasKind Gamma5 Theta5 (kinded_type (T_RefType T5)) kind_KindStar
 | HasKindStruct : forall (X_list:list X) (Gamma5:Gamma) (Theta5:Theta) (SName5:SName) (x':exprvar) (T':T) (x'':exprvar) (T'':T),
     Is_true (is_T_of_T T') ->
     Is_true (is_T_of_T T'') ->
      (Exists_list (fun p => p =  (theta_item (itemstruct SName5 X_list x' T' x'' T'')) )  Theta5 )  ->
     HasKind Gamma5 Theta5 (kinded_type (T_StructType SName5))  (fold_right (fun k accum => kind_ArrowKind k accum )   kind_KindStar   (map (fun (X_:X) =>  (kindOf X_ ) ) X_list)  ) 
 | HasKindApp : forall (Gamma5:Gamma) (Theta5:Theta) (T5:T) (K5 K':K) (tau5:T),
     Is_true (is_T_of_T T5) ->
     Is_true (is_tau_of_T tau5) ->
     Is_true (is_tau_of_T tau5) ->
     HasKind Gamma5 Theta5 (kinded_type T5) (kind_ArrowKind K' K5) ->
     HasKind Gamma5 Theta5 (kinded_type tau5) K' ->
     HasKind Gamma5 Theta5 (kinded_type (T_TyApp T5 tau5)) K5
 | HasKindAssoc : forall (Gamma5:Gamma) (Theta5:Theta) (X5:X) (beta5:beta),
     Is_true (is_beta_of_beta beta5) ->
     HasKind Gamma5 Theta5 (kinded_impl beta5) kind_Bound ->
     HasKind Gamma5 Theta5 (kinded_type (T_Assoc X5 beta5))  (kindOf X5 ) 
 | HasKindexists : forall (Gamma5:Gamma) (Theta5:Theta) (X5:X) (beta5:beta),
     Is_true (is_beta_of_beta beta5) ->
     HasKind Gamma5 Theta5 (kinded_type (T_TraitObj X5 beta5)) kind_KindStar
 | HasKindTypeHasBound : forall (Gamma5:Gamma) (Theta5:Theta) (beta5:beta) (tau5:T),
     Is_true (is_tau_of_T tau5) ->
     Is_true (is_beta_of_beta beta5) ->
     Is_true (is_tau_of_T tau5) ->
     HasKind Gamma5 Theta5 (kinded_type tau5) kind_KindStar ->
     HasKind Gamma5 Theta5 (kinded_impl beta5) kind_Bound ->
     HasKind Gamma5 Theta5 (kinded_constr  ( (pi_trtBound tau5 beta5) ) ) kind_Constr
 | HasKindQuantBound : forall (X_list:list X) (Gamma5:Gamma) (Theta5:Theta) (X_5:X) (pi5:pi) (beta5:beta) (tau5:T),
     Is_true (is_pi_of_pi pi5) ->
     Is_true (is_tau_of_T tau5) ->
     Is_true (is_beta_of_beta beta5) ->
     Is_true (is_tau_of_T tau5) ->
     HasKind  (  (cons (gamma_tvar X_5) nil)  ++   (  (  (map (fun (X_:X) => (gamma_tvar X_)) X_list)  ++  Gamma5  )  )   )  Theta5 (kinded_constr pi5) kind_Constr ->
     HasKind  (  (cons (gamma_tvar X_5) nil)  ++   (  (  (map (fun (X_:X) => (gamma_tvar X_)) X_list)  ++  Gamma5  )  )   )  Theta5 (kinded_type tau5) kind_KindStar ->
     HasKind  (  (cons (gamma_tvar X_5) nil)  ++   (  (  (map (fun (X_:X) => (gamma_tvar X_)) X_list)  ++  Gamma5  )  )   )  Theta5 (kinded_impl beta5) kind_Bound ->
     HasKind Gamma5 Theta5 (kinded_constr  ( (pi_forall ((app (cons X_5 nil) (app X_list nil))) pi5 tau5 beta5) ) ) kind_Constr
 | HasKindConj : forall (Gamma5:Gamma) (Theta5:Theta) (pi1 pi2:pi),
     Is_true (is_pi_of_pi pi1) ->
     Is_true (is_pi_of_pi pi2) ->
     HasKind Gamma5 Theta5 (kinded_constr pi1) kind_Constr ->
     HasKind Gamma5 Theta5 (kinded_constr pi2) kind_Constr ->
     HasKind Gamma5 Theta5 (kinded_constr (pi_conj pi1 pi2)) kind_Constr
 | HasKindTraitDecl : forall (X_list:list X) (Gamma5:Gamma) (Theta5:Theta) (D5:D) (pi5:pi) (X':X) (fundecl5:fundecl),
     Is_true (is_pi_of_pi pi5) ->
     Is_true (is_fundecl_of_fundecl fundecl5) ->
      (Exists_list (fun p => p =  (theta_item (itemtraitdecl D5 X_list pi5 X' fundecl5)) )  Theta5 )  ->
     HasKind Gamma5 Theta5 (kinded_impl (beta_TraitName D5))  (fold_right (fun k accum => kind_ArrowKind k accum )   kind_Bound   (map (fun (X_:X) =>  (kindOf X_ ) ) X_list)  ) 
 | HasKindBetaApp : forall (Gamma5:Gamma) (Theta5:Theta) (beta5:beta) (K5 K':K) (tau5:T),
     Is_true (is_beta_of_beta beta5) ->
     Is_true (is_tau_of_T tau5) ->
     Is_true (is_tau_of_T tau5) ->
     HasKind Gamma5 Theta5 (kinded_impl beta5) (kind_ArrowKind K' K5) ->
     HasKind Gamma5 Theta5 (kinded_type tau5) K' ->
     HasKind Gamma5 Theta5 (kinded_impl (beta_TypeApp beta5 tau5)) K5
 | HasKindBetaElab : forall (Gamma5:Gamma) (Theta5:Theta) (beta5:beta) (f:exprvar) (e5:e),
     Is_true (is_beta_of_beta beta5) ->
     Is_true (is_e_of_e e5) ->
     HasKind Gamma5 Theta5 (kinded_impl beta5) kind_Bound ->
     HasKind Gamma5 Theta5 (kinded_impl (beta_elab beta5 f e5)) kind_Bound
 | HasKindBetaAssoc : forall (X'_list:list X) (tau_Y_list:list (T*X)) (Gamma5:Gamma) (Theta5:Theta) (D5:D) (X':X) (tau'1 tau' tau_5:T) (K':K) (pi5:pi) (fundecl5:fundecl) (X5:X),
     Is_true (is_tau_of_T tau'1) ->
     Is_true (is_tau_of_T tau') ->
     Is_true (is_tau_of_T tau_5) ->
     Is_true (is_pi_of_pi pi5) ->
     Is_true (is_fundecl_of_fundecl fundecl5) ->
     (Forall (fun (tmp_:(T*X)) => match tmp_ with (tau_,Y_) => Is_true (is_tau_of_T tau_) end) tau_Y_list) ->
     HasKind Gamma5 Theta5 (kinded_impl  (fold_right (fun tau accum => beta_TypeApp accum tau ) 
    (fold_right 
      (fun pair accum => beta_Assoc accum (fst pair) (snd pair) )
      (beta_TraitName  D5 )
      (  X'   )  tau'  
    ) 
     (map (fun (pat_:(T*X)) => match pat_ with (tau_,Y_) => tau_ end ) tau_Y_list) ) ) kind_Bound ->
     HasKind Gamma5 Theta5 (kinded_type tau_5) K' ->
      (Exists_list (fun p => p =  (theta_item (itemtraitdecl D5 (map (fun (pat_:(T*X)) => match pat_ with (tau_,Y_) => Y_ end ) tau_Y_list) pi5 X' fundecl5)) )  Theta5 )  ->
      (Exists_list (fun X_ => X_ =  X5 )  X'_list )  ->
     HasKind Gamma5 Theta5 (kinded_type tau_5)  (kindOf X5 )  ->
     HasKind Gamma5 Theta5 (kinded_impl  (fold_right (fun tau accum => beta_TypeApp accum tau ) 
    (fold_right 
      (fun pair accum => beta_Assoc accum (fst pair) (snd pair) )
      (beta_TraitName  D5 )
      (  X'   )  tau'1  
    ) 
     (map (fun (pat_:(T*X)) => match pat_ with (tau_,Y_) => tau_ end ) tau_Y_list) ) ) kind_Bound
with tstep : Gamma -> Theta -> T -> T -> Prop :=    (* defn tstep *)
 | TStepRefl : forall (Gamma5:Gamma) (Theta5:Theta) (T5:T),
     Is_true (is_T_of_T T5) ->
     tstep Gamma5 Theta5 T5 T5
 | TStepAssoc : forall (tau_list:list T) (Gamma5:Gamma) (Theta5:Theta) (T5 T' tau_5:T) (D5:D) (X_5:X) (tau':T) (X_:X),
     Is_true (is_T_of_T T5) ->
     Is_true (is_T_of_T T') ->
     Is_true (is_tau_of_T tau_5) ->
     Is_true (is_tau_of_T tau') ->
     (Forall (fun (tau_:T) => Is_true (is_tau_of_T tau_)) tau_list) ->
     entail Gamma5 Theta5 (pi_trtBound tau_5  (fold_right (fun tau accum => beta_TypeApp accum tau ) 
    (fold_right 
      (fun pair accum => beta_Assoc accum (fst pair) (snd pair) )
      (beta_TraitName  D5 )
      (  X_5   )  tau'  
    ) 
     tau_list ) ) ->
     tstep Gamma5 Theta5  (  (assocSubst_T  tau'   (assocType_name X_  (  TODOsugar1  ) )   T5 )  )  T' ->
     tstep Gamma5 Theta5 T5 T'
with convertsTo : Gamma -> Theta -> T -> T -> CC -> Prop :=    (* defn convertsTo *)
 | CoerceRefl : forall (Gamma5:Gamma) (Theta5:Theta) (T5:T),
     Is_true (is_T_of_T T5) ->
     convertsTo Gamma5 Theta5 T5 T5 coercionContext_empty
 | CoerceInstL : forall (X_tau_tau_list:list (X*T*T)) (Gamma5:Gamma) (Theta5:Theta) (pi5:pi) (T5 T':T),
     Is_true (is_pi_of_pi pi5) ->
     Is_true (is_T_of_T T5) ->
     Is_true (is_T_of_T T') ->
     (Forall (fun (tmp_:(X*T*T)) => match tmp_ with (X_,tau_,_) => Is_true (is_tau_of_T tau_) end) X_tau_tau_list) ->
     (Forall (fun (tmp_:(X*T*T)) => match tmp_ with (X_,tau_,_) => Is_true (is_tau_of_T tau_) end) X_tau_tau_list) ->
     (forall tau_ X_, In (tau_,X_) (map (fun (pat_: (X*T*T)) => match pat_ with (X_,tau_,_) => (tau_,X_) end) X_tau_tau_list) -> (HasKind Gamma5 Theta5 (kinded_type tau_)  (kindOf X_ ) )) ->
     convertsTo Gamma5 Theta5  ( (T_polyarrow (map (fun (pat_:(X*T*T)) => match pat_ with (X_,tau_,_) => X_ end ) X_tau_tau_list) pi5  ( T5 )  T') )   (  (tsubst_T  (map (fun (pat_:(X*T*T)) => match pat_ with (X_,tau_,_) => (X_,tau_) end ) X_tau_tau_list)    (  (T_polyarrow nil  pi5    ( T5 )    T' )  )  )  )  (coercionContext_spec (map (fun (pat_:(X*T*T)) => match pat_ with (X_,tau_,_) => tau_ end ) X_tau_tau_list))
 | CoerceInstR : forall (X_X'_list:list (X*X)) (Gamma5:Gamma) (Theta5:Theta) (T'':T) (pi5:pi) (T5 T':T) (CC5:CC),
     Is_true (is_T_of_T T'') ->
     Is_true (is_pi_of_pi pi5) ->
     Is_true (is_T_of_T T5) ->
     Is_true (is_T_of_T T') ->
     Is_true (is_CC_of_CC CC5) ->
     (forall X'_, In (X'_) (map (fun (pat_: (X*X)) => match pat_ with (X_,X'_) => (X'_) end) X_X'_list) ->  ( false =  (list_mem eq_gamma (gamma_tvar  X'_  )  Gamma5 ) ) ) ->
     convertsTo Gamma5 Theta5 T''  (tsubst_T  (map (fun (pat_:(X*X)) => match pat_ with (X_,X'_) => (X_,(T_var X'_)) end ) X_X'_list)    (  (T_polyarrow nil  pi5    ( T5 )    T' )  )  )  CC5 ->
     convertsTo Gamma5 Theta5 T'' (T_polyarrow (map (fun (pat_:(X*X)) => match pat_ with (X_,X'_) => X_ end ) X_X'_list) pi5  ( T5 )  T') (coercionContext_gen (map (fun (pat_:(X*X)) => match pat_ with (X_,X'_) => X_ end ) X_X'_list) CC5)
 | CoerceObj : forall (tau_list:list T) (Gamma5:Gamma) (Theta5:Theta) (X5:X) (D5:D) (X':X) (tau':T) (beta5:beta) (f:exprvar) (tau_5:T) (v5:e),
     Is_true (is_tau_of_T tau_5) ->
     Is_true (is_tau_of_T tau') ->
     Is_true (is_beta_of_beta beta5) ->
     Is_true (is_v_of_e v5) ->
     Is_true (is_tau_of_T tau_5) ->
     Is_true (is_v_of_e v5) ->
     (Forall (fun (tau_:T) => Is_true (is_tau_of_T tau_)) tau_list) ->
     entail Gamma5 Theta5 (pi_trtBound tau_5 (beta_elab  (fold_right (fun tau accum => beta_TypeApp accum tau ) 
    (fold_right 
      (fun pair accum => beta_Assoc accum (fst pair) (snd pair) )
      (beta_TraitName  D5 )
      (  X'   )  tau'  
    ) 
     tau_list )  f v5)) ->
     entail Gamma5 Theta5 (pi_trtBound (T_TraitObj X5  (fold_right (fun tau accum => beta_TypeApp accum tau ) 
    (fold_right 
      (fun pair accum => beta_Assoc accum (fst pair) (snd pair) )
      (beta_TraitName  D5 )
      (  X'   )  tau'  
    ) 
     tau_list ) )  (fold_right (fun tau accum => beta_TypeApp accum tau ) 
    (fold_right 
      (fun pair accum => beta_Assoc accum (fst pair) (snd pair) )
      (beta_TraitName  D5 )
      (  X'   )  tau'  
    ) 
     tau_list ) ) ->
     convertsTo Gamma5 Theta5 (T_RefType tau_5) (T_TraitObj X5  (fold_right (fun tau accum => beta_TypeApp accum tau ) 
    (fold_right 
      (fun pair accum => beta_Assoc accum (fst pair) (snd pair) )
      (beta_TraitName  D5 )
      (  X'   )  tau'  
    ) 
     tau_list ) ) (coercionContext_obj X5 beta5 (T_RefType tau_5) f v5)
with check : Gamma -> Theta -> e -> e -> T -> Prop :=    (* defn check *)
 | CheckEval : forall (Gamma5:Gamma) (Theta5:Theta) (e5 e':e) (T5 T':T),
     Is_true (is_e_of_e e5) ->
     Is_true (is_e_of_e e') ->
     Is_true (is_T_of_T T5) ->
     Is_true (is_T_of_T T') ->
     tstep Gamma5 Theta5 T5 T' ->
     check Gamma5 Theta5 e5 e' T' ->
     check Gamma5 Theta5 e5 e' T5
 | CheckCoerce : forall (Gamma5:Gamma) (Theta5:Theta) (e5:e) (CC5:CC) (e':e) (T5 T':T),
     Is_true (is_e_of_e e5) ->
     Is_true (is_CC_of_CC CC5) ->
     Is_true (is_e_of_e e') ->
     Is_true (is_T_of_T T5) ->
     Is_true (is_T_of_T T') ->
     synth Gamma5 Theta5 e5 e' T' ->
     convertsTo Gamma5 Theta5 T' T5 CC5 ->
     check Gamma5 Theta5 e5 (exprAnnot  (appctx_CC_expr  CC5   e' )  T5) T5
 | CheckStruct : forall (tau_X_list:list (T*X)) (Gamma5:Gamma) (Theta5:Theta) (SName5:SName) (x1:exprvar) (e1:e) (x2:exprvar) (e2 e'1 e'2:e) (T1 T2:T) (e1' e2':e),
     Is_true (is_e_of_e e1) ->
     Is_true (is_e_of_e e2) ->
     Is_true (is_e_of_e e'1) ->
     Is_true (is_e_of_e e'2) ->
     Is_true (is_T_of_T T1) ->
     Is_true (is_T_of_T T2) ->
     Is_true (is_e_of_e e1') ->
     Is_true (is_e_of_e e2') ->
     (Forall (fun (tmp_:(T*X)) => match tmp_ with (tau_,X_) => Is_true (is_tau_of_T tau_) end) tau_X_list) ->
      (Exists_list (fun p => p =  (theta_item (itemstruct SName5 (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => X_ end ) tau_X_list) x1 T1 x2 T2)) )  Theta5 )  ->
     HasKind Gamma5 Theta5 (kinded_type  (fold_right (fun ty accum => T_TyApp accum ty )   (T_StructType SName5)   (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => tau_ end ) tau_X_list)  ) ) kind_KindStar ->
     check Gamma5 Theta5 e1 e1'  (tsubst_T  (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => (X_,tau_) end ) tau_X_list)   T1 )  ->
     check Gamma5 Theta5 e2 e2'  (tsubst_T  (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => (X_,tau_) end ) tau_X_list)   T2 )  ->
     check Gamma5 Theta5 (exprStructInit SName5 x1 e1 x2 e2) (exprAnnot (exprStructInit SName5 x1 e'1 x2 e'2)  (  (fold_right (fun ty accum => T_TyApp accum ty )   (T_StructType SName5)   (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => tau_ end ) tau_X_list)  )  ) )  (fold_right (fun ty accum => T_TyApp accum ty )   (T_StructType SName5)   (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => tau_ end ) tau_X_list)  ) 
 | CheckCtor : forall (tau_X_list:list (T*X)) (Gamma5:Gamma) (Theta5:Theta) (CtorName_5:CtorName) (EnumName5:EnumName) (e5:e) (CtorName1:CtorName) (T1:T) (CtorName2:CtorName) (T2 T_5:T) (e':e),
     Is_true (is_e_of_e e5) ->
     Is_true (is_T_of_T T1) ->
     Is_true (is_T_of_T T2) ->
     Is_true (is_T_of_T T_5) ->
     Is_true (is_e_of_e e') ->
     (Forall (fun (tmp_:(T*X)) => match tmp_ with (tau_,X_) => Is_true (is_tau_of_T tau_) end) tau_X_list) ->
      (Exists_list (fun p => p =  (theta_item (itemenum EnumName5 (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => X_ end ) tau_X_list) CtorName1 T1 CtorName2 T2)) )  Theta5 )  ->
     (formula_cchoiceT CtorName_5 T_5 CtorName1 T1 CtorName2 T2) ->
     HasKind Gamma5 Theta5 (kinded_type  (fold_right (fun ty accum => T_TyApp accum ty )   (T_EnumType EnumName5)   (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => tau_ end ) tau_X_list)  ) ) kind_KindStar ->
     check Gamma5 Theta5 e5 e'  (tsubst_T  (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => (X_,tau_) end ) tau_X_list)   T_5 )  ->
     check Gamma5 Theta5 (exprCApp CtorName_5 EnumName5 e5) (exprAnnot (exprCApp CtorName_5 EnumName5 e5)  (  (fold_right (fun ty accum => T_TyApp accum ty )   (T_EnumType EnumName5)   (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => tau_ end ) tau_X_list)  )  ) )  (fold_right (fun ty accum => T_TyApp accum ty )   (T_EnumType EnumName5)   (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => tau_ end ) tau_X_list)  ) 
with synth : Gamma -> Theta -> e -> e -> T -> Prop :=    (* defn synth *)
 | SynthVar : forall (Gamma5:Gamma) (Theta5:Theta) (x:exprvar) (T5:T),
     Is_true (is_T_of_T T5) ->
      (Exists_list (fun g => g =  (gamma_evar x T5)  )  Gamma5 )  ->
     synth Gamma5 Theta5 (exprVar x) (exprVar x) T5
 | SynthAnn : forall (Gamma5:Gamma) (Theta5:Theta) (e5:e) (T5:T) (e':e),
     Is_true (is_e_of_e e5) ->
     Is_true (is_T_of_T T5) ->
     Is_true (is_e_of_e e') ->
     check Gamma5 Theta5 e5 e' T5 ->
     synth Gamma5 Theta5 (exprAnnot e5 T5) (exprAnnot e' T5) T5
 | SynthUnit : forall (Gamma5:Gamma) (Theta5:Theta),
     synth Gamma5 Theta5 exprUnit exprUnit T_UType
 | SynthEval : forall (Gamma5:Gamma) (Theta5:Theta) (e5 e':e) (T5 T':T),
     Is_true (is_e_of_e e5) ->
     Is_true (is_e_of_e e') ->
     Is_true (is_T_of_T T5) ->
     Is_true (is_T_of_T T') ->
     synth Gamma5 Theta5 e5 e' T' ->
     tstep Gamma5 Theta5 T' T5 ->
     synth Gamma5 Theta5 e5 e' T5
 | SynthAssign : forall (Gamma5:Gamma) (Theta5:Theta) (e5 e' lv5 lv':e) (T5:T),
     Is_true (is_lv_of_e lv5) ->
     Is_true (is_e_of_e e5) ->
     Is_true (is_lv_of_e lv') ->
     Is_true (is_e_of_e e') ->
     Is_true (is_lv_of_e lv5) ->
     Is_true (is_lv_of_e lv') ->
     Is_true (is_T_of_T T5) ->
     synth Gamma5 Theta5 lv5 lv' T5 ->
     check Gamma5 Theta5 e5 e' T5 ->
     synth Gamma5 Theta5 (exprAssign lv5 e5) (exprAssign lv' e') T_UType
 | SynthSeq : forall (Gamma5:Gamma) (Theta5:Theta) (e1 e2 e'1 e'2:e) (T_5 T1:T),
     Is_true (is_e_of_e e1) ->
     Is_true (is_e_of_e e2) ->
     Is_true (is_e_of_e e'1) ->
     Is_true (is_e_of_e e'2) ->
     Is_true (is_T_of_T T_5) ->
     Is_true (is_T_of_T T1) ->
     synth Gamma5 Theta5 e1 e'1 T1 ->
     synth Gamma5 Theta5 e2 e'2 T_5 ->
     synth Gamma5 Theta5 (exprSeq e1 e2) (exprSeq e'1 e'2) T_5
 | SynthDeref : forall (Gamma5:Gamma) (Theta5:Theta) (e5 e':e) (T5:T),
     Is_true (is_e_of_e e5) ->
     Is_true (is_e_of_e e') ->
     Is_true (is_T_of_T T5) ->
     synth Gamma5 Theta5 e5 e' (T_RefType T5) ->
     synth Gamma5 Theta5 (exprDeref e5) (exprDeref e') T5
 | SynthLet : forall (Gamma5:Gamma) (Theta5:Theta) (x:exprvar) (e1 e2 e'1 e'2:e) (T_5 T1:T),
     Is_true (is_e_of_e e1) ->
     Is_true (is_e_of_e e2) ->
     Is_true (is_e_of_e e'1) ->
     Is_true (is_e_of_e e'2) ->
     Is_true (is_T_of_T T_5) ->
     Is_true (is_T_of_T T1) ->
     synth Gamma5 Theta5 e1 e'1 T1 ->
     synth  (  (cons (gamma_evar x T1) nil)  ++  Gamma5  )  Theta5 e2 e'2 T_5 ->
     synth Gamma5 Theta5 (exprLet x e1 e2) (exprLet x e'1 e'2) T_5
 | SynthRef : forall (Gamma5:Gamma) (Theta5:Theta) (T5:T) (lv5 lv':e),
     Is_true (is_lv_of_e lv5) ->
     Is_true (is_lv_of_e lv') ->
     Is_true (is_T_of_T T5) ->
     Is_true (is_lv_of_e lv5) ->
     Is_true (is_lv_of_e lv') ->
     synth Gamma5 Theta5 lv5 lv' T5 ->
     synth Gamma5 Theta5 (exprRef lv5) (exprRef lv') (T_RefType T5)
 | SynthApp : forall (tau_X_list:list (T*X)) (Gamma5:Gamma) (Theta5:Theta) (e1 e2 e'1 e'2:e) (T_5:T) (pi5:pi) (T1:T),
     Is_true (is_e_of_e e1) ->
     Is_true (is_e_of_e e2) ->
     Is_true (is_e_of_e e'1) ->
     Is_true (is_e_of_e e'2) ->
     Is_true (is_T_of_T T_5) ->
     Is_true (is_pi_of_pi pi5) ->
     Is_true (is_T_of_T T1) ->
     (Forall (fun (tmp_:(T*X)) => match tmp_ with (tau_,X_) => Is_true (is_tau_of_T tau_) end) tau_X_list) ->
     synth Gamma5 Theta5 e1 e'1 (T_polyarrow (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => X_ end ) tau_X_list) pi5 T1 T_5) ->
     HasKind Gamma5 Theta5 (kinded_type  (tsubst_T  (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => (X_,tau_) end ) tau_X_list)    (  (T_polyarrow nil  pi5   T1   T_5 )  )  ) ) kind_KindStar ->
     entail Gamma5 Theta5  (tsubst_pi  (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => (X_,tau_) end ) tau_X_list)   pi5 )  ->
     check Gamma5 Theta5 e2 e'2  (tsubst_T  (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => (X_,tau_) end ) tau_X_list)   T1 )  ->
     synth Gamma5 Theta5 (exprApp e1 e2) (exprApp  ( (exprInternal (internalspec e'1 (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => tau_ end ) tau_X_list))) )  e'2)  (tsubst_T  (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => (X_,tau_) end ) tau_X_list)   T_5 ) 
 | SynthStruct : forall (tau_X_list:list (T*X)) (Gamma5:Gamma) (Theta5:Theta) (SName5:SName) (x1:exprvar) (e1:e) (x2:exprvar) (e2 e'1 e'2:e) (T1 T2:T) (e1' e2':e),
     Is_true (is_e_of_e e1) ->
     Is_true (is_e_of_e e2) ->
     Is_true (is_e_of_e e'1) ->
     Is_true (is_e_of_e e'2) ->
     Is_true (is_T_of_T T1) ->
     Is_true (is_T_of_T T2) ->
     Is_true (is_e_of_e e1') ->
     Is_true (is_e_of_e e2') ->
     (Forall (fun (tmp_:(T*X)) => match tmp_ with (tau_,X_) => Is_true (is_tau_of_T tau_) end) tau_X_list) ->
      (Exists_list (fun p => p =  (theta_item (itemstruct SName5 (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => X_ end ) tau_X_list) x1 T1 x2 T2)) )  Theta5 )  ->
     HasKind Gamma5 Theta5 (kinded_type  (fold_right (fun ty accum => T_TyApp accum ty )   (T_StructType SName5)   (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => tau_ end ) tau_X_list)  ) ) kind_KindStar ->
     check Gamma5 Theta5 e1 e1'  (tsubst_T  (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => (X_,tau_) end ) tau_X_list)   T1 )  ->
     check Gamma5 Theta5 e2 e2'  (tsubst_T  (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => (X_,tau_) end ) tau_X_list)   T2 )  ->
     synth Gamma5 Theta5 (exprStructInit SName5 x1 e1 x2 e2) (exprAnnot (exprStructInit SName5 x1 e'1 x2 e'2)  (  (fold_right (fun ty accum => T_TyApp accum ty )   (T_StructType SName5)   (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => tau_ end ) tau_X_list)  )  ) )  (fold_right (fun ty accum => T_TyApp accum ty )   (T_StructType SName5)   (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => tau_ end ) tau_X_list)  ) 
 | SynthProj : forall (X_tau_list:list (X*T)) (Gamma5:Gamma) (Theta5:Theta) (e5:e) (x1:exprvar) (e':e) (T1:T) (SName5:SName) (x2:exprvar) (T2:T),
     Is_true (is_e_of_e e5) ->
     Is_true (is_e_of_e e') ->
     Is_true (is_T_of_T T1) ->
     Is_true (is_T_of_T T2) ->
     (Forall (fun (tmp_:(X*T)) => match tmp_ with (X_,tau_) => Is_true (is_tau_of_T tau_) end) X_tau_list) ->
     synth Gamma5 Theta5 e5 e'  (fold_right (fun ty accum => T_TyApp accum ty )   (T_StructType SName5)   (map (fun (pat_:(X*T)) => match pat_ with (X_,tau_) => tau_ end ) X_tau_list)  )  ->
      (Exists_list (fun p => p =  (theta_item (itemstruct SName5 (map (fun (pat_:(X*T)) => match pat_ with (X_,tau_) => X_ end ) X_tau_list) x1 T1 x2 T2)) )  Theta5 )  ->
     synth Gamma5 Theta5 (exprStructField e5 x1) (exprStructField e' x1)  (tsubst_T  X_tau_list   T1 ) 
 | SynthCtor : forall (tau_X_list:list (T*X)) (Gamma5:Gamma) (Theta5:Theta) (CtorName_5:CtorName) (EnumName5:EnumName) (e5 e':e) (CtorName1:CtorName) (T1:T) (CtorName2:CtorName) (T2 T_5:T),
     Is_true (is_e_of_e e5) ->
     Is_true (is_e_of_e e') ->
     Is_true (is_T_of_T T1) ->
     Is_true (is_T_of_T T2) ->
     Is_true (is_T_of_T T_5) ->
     (Forall (fun (tmp_:(T*X)) => match tmp_ with (tau_,X_) => Is_true (is_tau_of_T tau_) end) tau_X_list) ->
      (Exists_list (fun p => p =  (theta_item (itemenum EnumName5 (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => X_ end ) tau_X_list) CtorName1 T1 CtorName2 T2)) )  Theta5 )  ->
     HasKind Gamma5 Theta5 (kinded_type  (fold_right (fun ty accum => T_TyApp accum ty )   (T_EnumType EnumName5)   (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => tau_ end ) tau_X_list)  ) ) kind_KindStar ->
     (formula_cchoiceT CtorName_5 T_5 CtorName1 T1 CtorName2 T2) ->
     check Gamma5 Theta5 e5 e'  (tsubst_T  (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => (X_,tau_) end ) tau_X_list)   T_5 )  ->
     synth Gamma5 Theta5 (exprCApp CtorName_5 EnumName5 e5) (exprAnnot (exprCApp CtorName_5 EnumName5 e')  (  (fold_right (fun ty accum => T_TyApp accum ty )   (T_EnumType EnumName5)   (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => tau_ end ) tau_X_list)  )  ) )  (fold_right (fun ty accum => T_TyApp accum ty )   (T_EnumType EnumName5)   (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => tau_ end ) tau_X_list)  ) 
 | SynthMatch : forall (X_tau_list:list (X*T)) (Gamma5:Gamma) (Theta5:Theta) (e_5:e) (CtorName1:CtorName) (EnumName5:EnumName) (x1:exprvar) (e1:e) (CtorName2:CtorName) (x2:exprvar) (e2 e3:e) (T_5 T1 T2:T) (e' e'1 e'2:e),
     Is_true (is_e_of_e e_5) ->
     Is_true (is_e_of_e e1) ->
     Is_true (is_e_of_e e2) ->
     Is_true (is_e_of_e e3) ->
     Is_true (is_T_of_T T_5) ->
     Is_true (is_T_of_T T1) ->
     Is_true (is_T_of_T T2) ->
     Is_true (is_e_of_e e') ->
     Is_true (is_e_of_e e'1) ->
     Is_true (is_e_of_e e'2) ->
     (Forall (fun (tmp_:(X*T)) => match tmp_ with (X_,tau_) => Is_true (is_tau_of_T tau_) end) X_tau_list) ->
      (Exists_list (fun p => p =  (theta_item (itemenum EnumName5 (map (fun (pat_:(X*T)) => match pat_ with (X_,tau_) => X_ end ) X_tau_list) CtorName1 T1 CtorName2 T2)) )  Theta5 )  ->
     synth Gamma5 Theta5 e_5 e'  (fold_right (fun ty accum => T_TyApp accum ty )   (T_EnumType EnumName5)   (map (fun (pat_:(X*T)) => match pat_ with (X_,tau_) => tau_ end ) X_tau_list)  )  ->
     synth  (  (cons (gamma_evar x1  (tsubst_T  X_tau_list   T1 ) ) nil)  ++  Gamma5  )  Theta5 e1 e'1 T_5 ->
     synth  (  (cons (gamma_evar x2  (tsubst_T  X_tau_list   T2 ) ) nil)  ++  Gamma5  )  Theta5 e2 e'2 T_5 ->
     (formula_eeq e3 (exprmatch e' CtorName1 EnumName5 x1 e'1 CtorName2 EnumName5 x2 e'2)) ->
     synth Gamma5 Theta5 (exprmatch e_5 CtorName1 EnumName5 x1 e1 CtorName2 EnumName5 x2 e2) e3 T_5
with internalTyping : Gamma -> Theta -> sigma -> e -> T -> Prop :=    (* defn internalTyping *)
 | InternalTypeSynth : forall (loc_tau_x_T_list:list (loc*T*exprvar*T)) (UNK: NUM 1:UNK_CTP) (Gamma5:Gamma) (Theta5:Theta) (sigma5:sigma) (e5:e) (tau_5:T) (t101 t102:(loc*T*exprvar*T)),
          nth_error loc_tau_x_T_list 1 = Some t101 ->
     nth_error loc_tau_x_T_list 1 = Some t102 ->
Is_true (is_e_of_e e5) ->
     Is_true (is_tau_of_T tau_5) ->
     (Forall (fun (tmp_:(loc*T*exprvar*T)) => match tmp_ with (loc_,tau_,x_,T_) => Is_true (is_tau_of_T tau_) end) loc_tau_x_T_list) ->
     (Forall (fun (tmp_:(loc*T*exprvar*T)) => match tmp_ with (loc_,tau_,x_,T_) => Is_true (is_T_of_T T_) end) loc_tau_x_T_list) ->
     (formula_sigmaDom sigma5 (map (fun (pat_:(loc*T*exprvar*T)) => match pat_ with (loc_,tau_,x_,T_) => loc_ end ) loc_tau_x_T_list)) ->
     (forall (match t102 with (loc_,tau_,x_,T_) => x_ end), In ((match t102 with (loc_,tau_,x_,T_) => x_ end)) (map (fun (pat_: (loc*T*exprvar*T)) => match pat_ with (loc_,tau_,x_,T_) => ((match t102 with (loc_,tau_,x_,T_) => x_ end)) end) loc_tau_x_T_list) -> (formula_xNotFree (match t101 with (loc_,tau_,x_,T_) => x_ end) Gamma5)) ->
     (forall loc_ tau_, In (loc_,tau_) (map (fun (pat_: (loc*T*exprvar*T)) => match pat_ with (loc_,tau_,x_,T_) => (loc_,tau_) end) loc_tau_x_T_list) ->  ( internalTyping Gamma5 Theta5 sigma5 (exprInternal (internalloc loc_)) tau_ ) ) ->
     synth  (  (map (fun (pat_:(loc*T*exprvar*T)) => match pat_ with (loc_,tau_,x_,T_) => (gamma_evar x_ T_) end ) loc_tau_x_T_list)  ++  Gamma5  )  Theta5 e5 e5 tau_5 ->
     internalTyping Gamma5 Theta5 sigma5 e5 tau_5
 | InternalTypeCtx : forall (loc_x_tau_T_list:list (loc*exprvar*T*T)) (UNK: NUM 0:UNK_CTP) (Gamma5:Gamma) (Theta5:Theta) (sigma5:sigma) (EC5:EC) (e5:e) (tau_5:T) (x:exprvar) (t103 t104:(loc*exprvar*T*T)),
          nth_error loc_x_tau_T_list 0 = Some t103 ->
     nth_error loc_x_tau_T_list 0 = Some t104 ->
Is_true (is_EC_of_EC EC5) ->
     Is_true (is_e_of_e e5) ->
     Is_true (is_tau_of_T tau_5) ->
     (Forall (fun (tmp_:(loc*exprvar*T*T)) => match tmp_ with (loc_,x_,tau_,T_) => Is_true (is_tau_of_T tau_) end) loc_x_tau_T_list) ->
     (Forall (fun (tmp_:(loc*exprvar*T*T)) => match tmp_ with (loc_,x_,tau_,T_) => Is_true (is_T_of_T T_) end) loc_x_tau_T_list) ->
     (formula_sigmaDom sigma5 (map (fun (pat_:(loc*exprvar*T*T)) => match pat_ with (loc_,x_,tau_,T_) => loc_ end ) loc_x_tau_T_list)) ->
     (formula_xNotFree x Gamma5) ->
     (forall x_, In (x_) (map (fun (pat_: (loc*exprvar*T*T)) => match pat_ with (loc_,x_,tau_,T_) => (x_) end) loc_x_tau_T_list) -> (formula_xNotFree x_ Gamma5)) ->
     internalTyping Gamma5 Theta5 sigma5 e5 (match t103 with (loc_,x_,tau_,T_) => tau_ end) ->
     (forall loc_ tau_, In (loc_,tau_) (map (fun (pat_: (loc*exprvar*T*T)) => match pat_ with (loc_,x_,tau_,T_) => (loc_,tau_) end) loc_x_tau_T_list) ->  ( internalTyping Gamma5 Theta5 sigma5 (exprInternal (internalloc loc_)) tau_ ) ) ->
     synth  (  (map (fun (pat_:(loc*exprvar*T*T)) => match pat_ with (loc_,x_,tau_,T_) => (gamma_evar x_ T_) end ) loc_x_tau_T_list)  ++   (  (  (cons (gamma_evar x (match t104 with (loc_,x_,tau_,T_) => T_ end)) nil)  ++  Gamma5  )  )   )  Theta5  (appctx_EC_expr  EC5   (exprVar x) )   (appctx_EC_expr  EC5   (exprVar x) )  tau_5 ->
     internalTyping Gamma5 Theta5 sigma5  (appctx_EC_expr  EC5   e5 )  tau_5
 | InternalTypeRawFun : forall (Gamma5:Gamma) (Theta5:Theta) (sigma5:sigma) (x:exprvar) (tau1:T) (e5:e) (tau2 T1:T),
     Is_true (is_tau_of_T tau1) ->
     Is_true (is_e_of_e e5) ->
     Is_true (is_tau_of_T tau2) ->
     Is_true (is_T_of_T T1) ->
     internalTyping  (  (cons (gamma_evar x T1) nil)  ++  Gamma5  )  Theta5 sigma5 e5 tau2 ->
     internalTyping Gamma5 Theta5 sigma5  ( (exprInternal (internalRawProc x tau1 e5 tau2)) )  tau2
 | InternalTypeTypeLambda : forall (X_list:list X) (Gamma5:Gamma) (Theta5:Theta) (sigma5:sigma) (e5:e) (T5 T':T),
     Is_true (is_e_of_e e5) ->
     Is_true (is_T_of_T T5) ->
     Is_true (is_T_of_T T') ->
     internalTyping  (  (map (fun (X_:X) => (gamma_tvar X_)) X_list)  ++  Gamma5  )  Theta5 sigma5 e5  (T_polyarrow nil  pi_empty   T5   T' )  ->
     internalTyping Gamma5 Theta5 sigma5  ( (exprInternal (internalgen X_list e5)) )  (T_polyarrow X_list pi_empty T5 T')
 | InternalTypeTypeInst : forall (tau_X_list:list (T*X)) (Gamma5:Gamma) (Theta5:Theta) (sigma5:sigma) (e5:e) (T5 T':T) (pi5:pi),
     Is_true (is_e_of_e e5) ->
     Is_true (is_T_of_T T5) ->
     Is_true (is_T_of_T T') ->
     Is_true (is_pi_of_pi pi5) ->
     (Forall (fun (tmp_:(T*X)) => match tmp_ with (tau_,X_) => Is_true (is_tau_of_T tau_) end) tau_X_list) ->
     internalTyping  (  (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => (gamma_tvar X_) end ) tau_X_list)  ++  Gamma5  )  Theta5 sigma5 e5 (T_polyarrow (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => X_ end ) tau_X_list) pi5 T5 T') ->
     entail  (  (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => (gamma_tvar X_) end ) tau_X_list)  ++  Gamma5  )  Theta5 pi5 ->
     internalTyping Gamma5 Theta5 sigma5 (exprInternal (internalspec e5 (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => tau_ end ) tau_X_list)))  (tsubst_T  (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => (X_,tau_) end ) tau_X_list)    (  (T_polyarrow nil  pi_empty   T5   T' )  )  ) 
 | InternalTypeLoc : forall (Gamma5:Gamma) (Theta5:Theta) (sigma5:sigma) (loc5:loc) (tau5:T) (v5:e),
     Is_true (is_tau_of_T tau5) ->
     Is_true (is_v_of_e v5) ->
      (lookup  loc5   sigma5  = Some  v5 )  ->
     internalTyping Gamma5 Theta5 sigma5 v5 tau5 ->
     internalTyping Gamma5 Theta5 sigma5 (exprInternal (internalloc loc5)) tau5
 | InternalTypeObj : forall (Gamma5:Gamma) (Theta5:Theta) (sigma5:sigma) (X5:X) (beta5:beta) (e5:e) (tau5:T) (f:exprvar) (v5:e),
     Is_true (is_beta_of_beta beta5) ->
     Is_true (is_e_of_e e5) ->
     Is_true (is_tau_of_T tau5) ->
     Is_true (is_v_of_e v5) ->
     internalTyping Gamma5 Theta5 sigma5 (exprInternal (internalobj X5 beta5 e5 tau5 f v5))  ( (T_TraitObj X5 beta5) ) 
with algoConvertsTo : Gamma -> Theta -> T -> T -> V -> P -> Prop :=    (* defn algoConvertsTo *)
 | AlgoCoerceInstL : forall (X_alpha_list:list (X*alpha)) (UNK: NUM 1:UNK_CTP) (Gamma5:Gamma) (Theta5:Theta) (pi5:pi) (T_5 T' T2:T) (P_5 P2:P) (t105:(X*alpha)),
          nth_error X_alpha_list 1 = Some t105 ->
Is_true (is_pi_of_pi pi5) ->
     Is_true (is_T_of_T T_5) ->
     Is_true (is_T_of_T T') ->
     Is_true (is_T_of_T T2) ->
     (formula_constrEq P_5 (probListSeq (map (fun (pat_:(X*alpha)) => match pat_ with (X_,alpha_) => (problemsKind Gamma5 Theta5 (T_unifVar alpha_)  (kindOf X_ ) ) end ) X_alpha_list))) ->
     (formula_constrEq P2 (probListLiteral (cons (problemsEq Gamma5 Theta5 T2  (tsubst_T  (map (fun (pat_:(X*alpha)) => match pat_ with (X_,alpha_) => (X_,(T_unifVar alpha_)) end ) X_alpha_list)    (  (T_polyarrow nil  pi5    ( T_5 )    T' )  )  ) ) nil))) ->
     (formula_disjointList (varListListvListList ((app (cons (varListSeq (cons (match t105 with (X_,alpha_) => alpha_ end) nil)) nil) (app (map (fun (pat_:(X*alpha)) => match pat_ with (X_,alpha_) => (varListLiteral (cons alpha_ nil)) end ) X_alpha_list) nil))))) ->
     algoConvertsTo Gamma5 Theta5  ( (T_polyarrow (map (fun (pat_:(X*alpha)) => match pat_ with (X_,alpha_) => X_ end ) X_alpha_list) pi5  ( T_5 )  T') )  T2 (varListSeq (map (fun (pat_:(X*alpha)) => match pat_ with (X_,alpha_) => alpha_ end ) X_alpha_list)) (probListUnion P_5 P2)
 | AlgoCoerceInstR : forall (X_X'_list:list (X*X)) (Gamma5:Gamma) (Theta5:Theta) (T'':T) (pi5:pi) (T5 T':T) (V5:V) (P5:P),
     Is_true (is_T_of_T T'') ->
     Is_true (is_pi_of_pi pi5) ->
     Is_true (is_T_of_T T5) ->
     Is_true (is_T_of_T T') ->
     (forall X'_, In (X'_) (map (fun (pat_: (X*X)) => match pat_ with (X_,X'_) => (X'_) end) X_X'_list) ->  ( false =  (list_mem eq_gamma (gamma_tvar  X'_  )  Gamma5 ) ) ) ->
     algoConvertsTo Gamma5 Theta5 T''  (tsubst_T  (map (fun (pat_:(X*X)) => match pat_ with (X_,X'_) => (X_,(T_var X'_)) end ) X_X'_list)    (  (T_polyarrow nil  pi5    ( T5 )    T' )  )  )  V5 P5 ->
     algoConvertsTo Gamma5 Theta5 T'' (T_polyarrow (map (fun (pat_:(X*X)) => match pat_ with (X_,X'_) => X_ end ) X_X'_list) pi5  ( T5 )  T') V5 P5
 | AlgoCoerceObjDefer : forall (Gamma5:Gamma) (Theta5:Theta) (alpha5:alpha) (X5:X) (beta5:beta) (P5:P),
     Is_true (is_beta_of_beta beta5) ->
     (formula_constrEq P5 (probListLiteral (cons (problemsSub Gamma5 Theta5 (T_unifVar alpha5) (T_TraitObj X5 beta5)) nil))) ->
     algoConvertsTo Gamma5 Theta5 (T_unifVar alpha5) (T_TraitObj X5 beta5) (varListLiteral nil) P5
 | AlgoCoerceObjRefDefer : forall (Gamma5:Gamma) (Theta5:Theta) (alpha5:alpha) (X5:X) (beta5:beta) (P5:P),
     Is_true (is_beta_of_beta beta5) ->
     (formula_constrEq P5 (probListLiteral (cons (problemsSub Gamma5 Theta5 (T_RefType (T_unifVar alpha5)) (T_TraitObj X5 beta5)) nil))) ->
     algoConvertsTo Gamma5 Theta5 (T_RefType (T_unifVar alpha5)) (T_TraitObj X5 beta5) (varListLiteral nil) P5
 | AlgoCoerceObj : forall (Gamma5:Gamma) (Theta5:Theta) (X5:X) (beta5:beta) (P5:P) (tau5:T),
     Is_true (is_tau_of_T tau5) ->
     Is_true (is_beta_of_beta beta5) ->
     Is_true (is_tau_of_T tau5) ->
     (formula_constrEq P5 (probListLiteral (cons (problemsEntails Gamma5 Theta5 (pi_trtBound tau5 beta5)) nil))) ->
     algoConvertsTo Gamma5 Theta5 (T_RefType tau5) (T_TraitObj X5 beta5) (varListLiteral nil) P5
 | AlgoCoerceTyRefDefer : forall (Gamma5:Gamma) (Theta5:Theta) (T5:T) (alpha5:alpha) (P5:P),
     Is_true (is_T_of_T T5) ->
     (formula_constrEq P5 (probListLiteral (cons (problemsSub Gamma5 Theta5 (T_RefType T5) (T_unifVar alpha5)) nil))) ->
     algoConvertsTo Gamma5 Theta5 (T_RefType T5) (T_unifVar alpha5) (varListLiteral nil) P5
 | AlgoCoerceVarDefer : forall (Gamma5:Gamma) (Theta5:Theta) (alpha5 alpha':alpha) (P5:P),
     (formula_constrEq P5 (probListLiteral (cons (problemsSub Gamma5 Theta5 (T_unifVar alpha5) (T_unifVar alpha')) nil))) ->
     algoConvertsTo Gamma5 Theta5 (T_unifVar alpha5) (T_unifVar alpha') (varListLiteral nil) P5
 | AlgoCoerceRefl : forall (Gamma5:Gamma) (Theta5:Theta) (T1 T2:T),
     Is_true (is_T_of_T T1) ->
     Is_true (is_T_of_T T2) ->
     formula_ruleelse ->
     algoConvertsTo Gamma5 Theta5 T1 T2 (varListLiteral nil) (probListLiteral (cons (problemsEq Gamma5 Theta5 T1 T2) nil))
with algoCheck : Gamma -> Theta -> e -> T -> V -> P -> Prop :=    (* defn algoCheck *)
 | AlgoCheckStruct : forall (tau_X_list:list (T*X)) (Gamma5:Gamma) (Theta5:Theta) (SName5:SName) (x1:exprvar) (e1:e) (x2:exprvar) (e2:e) (V1 V2:V) (P1 P2 P3:P) (T1 T2:T),
     Is_true (is_e_of_e e1) ->
     Is_true (is_e_of_e e2) ->
     Is_true (is_T_of_T T1) ->
     Is_true (is_T_of_T T2) ->
     (Forall (fun (tmp_:(T*X)) => match tmp_ with (tau_,X_) => Is_true (is_tau_of_T tau_) end) tau_X_list) ->
      (Exists_list (fun p => p =  (theta_item (itemstruct SName5 (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => X_ end ) tau_X_list) x1 T1 x2 T2)) )  Theta5 )  ->
     (formula_constrEq P3 (probListLiteral (cons (problemsKind Gamma5 Theta5  (fold_right (fun ty accum => T_TyApp accum ty )   (T_StructType SName5)   (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => tau_ end ) tau_X_list)  )  kind_KindStar) nil))) ->
     checkNorm Gamma5 Theta5 e1  (tsubst_T  (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => (X_,tau_) end ) tau_X_list)   T1 )  V1 P1 ->
     checkNorm Gamma5 Theta5 e2  (tsubst_T  (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => (X_,tau_) end ) tau_X_list)   T2 )  V2 P2 ->
     (formula_disjointList (varListListvListList ((app (cons V1 nil) (app (cons V2 nil) nil))))) ->
     algoCheck Gamma5 Theta5 (exprStructInit SName5 x1 e1 x2 e2)  (fold_right (fun ty accum => T_TyApp accum ty )   (T_StructType SName5)   (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => tau_ end ) tau_X_list)  )  (varListUnion V1 V2)  TODOparensconstrl 
 | AlgoCheckCtor : forall (tau_X_list:list (T*X)) (Gamma5:Gamma) (Theta5:Theta) (CtorName_5:CtorName) (EnumName5:EnumName) (e5:e) (V1:V) (P1 P2:P) (CtorName1:CtorName) (T1:T) (CtorName2:CtorName) (T2 T_5:T),
     Is_true (is_e_of_e e5) ->
     Is_true (is_T_of_T T1) ->
     Is_true (is_T_of_T T2) ->
     Is_true (is_T_of_T T_5) ->
     (Forall (fun (tmp_:(T*X)) => match tmp_ with (tau_,X_) => Is_true (is_tau_of_T tau_) end) tau_X_list) ->
      (Exists_list (fun p => p =  (theta_item (itemenum EnumName5 (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => X_ end ) tau_X_list) CtorName1 T1 CtorName2 T2)) )  Theta5 )  ->
     (formula_cchoiceT CtorName_5 T_5 CtorName1 T1 CtorName2 T2) ->
     (formula_constrEq P2 (probListLiteral (cons (problemsKind Gamma5 Theta5  (fold_right (fun ty accum => T_TyApp accum ty )   (T_EnumType EnumName5)   (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => tau_ end ) tau_X_list)  )  kind_KindStar) nil))) ->
     checkNorm Gamma5 Theta5 e5  (tsubst_T  (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => (X_,tau_) end ) tau_X_list)   T_5 )  V1 P1 ->
     algoCheck Gamma5 Theta5 (exprCApp CtorName_5 EnumName5 e5)  (fold_right (fun ty accum => T_TyApp accum ty )   (T_EnumType EnumName5)   (map (fun (pat_:(T*X)) => match pat_ with (tau_,X_) => tau_ end ) tau_X_list)  )  V1  TODOparensconstrl 
 | AlgoCheckCoerce : forall (Gamma5:Gamma) (Theta5:Theta) (e5:e) (T5:T) (V1 V2:V) (P1 P2:P) (T':T),
     Is_true (is_e_of_e e5) ->
     Is_true (is_T_of_T T5) ->
     Is_true (is_T_of_T T') ->
     synthNorm Gamma5 Theta5 e5 T' V1 P1 ->
     algoConvertsTo Gamma5 Theta5 T' T5 V2 P2 ->
     (formula_disjointList (varListListvListList ((app (cons V1 nil) (app (cons V2 nil) nil))))) ->
     formula_ruleelse ->
     algoCheck Gamma5 Theta5 e5 T5 (varListUnion V1 V2) (probListUnion P1 P2)
with synthNorm : Gamma -> Theta -> e -> T -> V -> P -> Prop :=    (* defn synthNorm *)
 | SynthNormPost : forall (Gamma5:Gamma) (Theta5:Theta) (e5:e) (T5:T) (V5:V) (P5:P) (T':T),
     Is_true (is_e_of_e e5) ->
     Is_true (is_T_of_T T5) ->
     Is_true (is_T_of_T T') ->
     algoSynth Gamma5 Theta5 e5 T' V5 P5 ->
     (formula_normal T5) ->
     tstep Gamma5 Theta5 T' T5 ->
     synthNorm Gamma5 Theta5 e5 T5 V5 P5
with checkNorm : Gamma -> Theta -> e -> T -> V -> P -> Prop :=    (* defn checkNorm *)
 | CheckNormPre : forall (Gamma5:Gamma) (Theta5:Theta) (e5:e) (T5:T) (V5:V) (P5:P) (T':T),
     Is_true (is_e_of_e e5) ->
     Is_true (is_T_of_T T5) ->
     Is_true (is_T_of_T T') ->
     tstep Gamma5 Theta5 T5 T' ->
     (formula_normal T') ->
     algoCheck Gamma5 Theta5 e5 T' V5 P5 ->
     checkNorm Gamma5 Theta5 e5 T5 V5 P5
with algoSynth : Gamma -> Theta -> e -> T -> V -> P -> Prop :=    (* defn algoSynth *)
 | AlgoSynthVar : forall (Gamma5:Gamma) (Theta5:Theta) (x:exprvar) (T5:T),
     Is_true (is_T_of_T T5) ->
      (Exists_list (fun g => g =  (gamma_evar x T5)  )  Gamma5 )  ->
     algoSynth Gamma5 Theta5 (exprVar x) T5 (varListLiteral nil) (probListLiteral nil)
 | AlgoSynthAnn : forall (Gamma5:Gamma) (Theta5:Theta) (e5:e) (T5:T) (V5:V) (P5:P),
     Is_true (is_e_of_e e5) ->
     Is_true (is_T_of_T T5) ->
     checkNorm Gamma5 Theta5 e5 T5 V5 P5 ->
     algoSynth Gamma5 Theta5 (exprAnnot e5 T5) T5 V5 P5
 | AlgoSynthDeref : forall (Gamma5:Gamma) (Theta5:Theta) (e5:e) (alpha5:alpha) (V_5:V) (P5:P) (T5:T) (V1:V),
     Is_true (is_e_of_e e5) ->
     Is_true (is_T_of_T T5) ->
     synthNorm Gamma5 Theta5 e5 T5 V_5 P5 ->
     (formula_disjointList (varListListvListList ((app (cons V1 nil) (app (cons (varListLiteral (cons alpha5 nil)) nil) nil))))) ->
     algoSynth Gamma5 Theta5 (exprDeref e5) (T_unifVar alpha5) (varListUnion V_5 (varListLiteral (cons alpha5 nil))) (probListUnion P5 (probListLiteral (cons (problemsEq Gamma5 Theta5 T5 (T_RefType (T_unifVar alpha5))) nil)))
 | AlgoSynthUnit : forall (Gamma5:Gamma) (Theta5:Theta),
     algoSynth Gamma5 Theta5 exprUnit T_UType (varListLiteral nil) (probListLiteral nil)
 | AlgoSynthLet : forall (Gamma5:Gamma) (Theta5:Theta) (x:exprvar) (e1 e2:e) (T1:T) (V1 V2:V) (P1 P2:P) (T_5:T),
     Is_true (is_e_of_e e1) ->
     Is_true (is_e_of_e e2) ->
     Is_true (is_T_of_T T1) ->
     Is_true (is_T_of_T T_5) ->
     synthNorm Gamma5 Theta5 e1 T1 V1 P1 ->
     algoSynth  (  (cons (gamma_evar x T1) nil)  ++  Gamma5  )  Theta5 e2 T_5 V2 P2 ->
     (formula_disjointList (varListListvListList ((app (cons V1 nil) (app (cons V2 nil) nil))))) ->
     algoSynth Gamma5 Theta5 (exprLet x e1 e2) T1 (varListUnion V1 V2) (probListUnion P1 P2)
 | AlgoSynthSeq : forall (Gamma5:Gamma) (Theta5:Theta) (e1 e2:e) (T_5:T) (V1 V2:V) (P1 P2:P) (T1:T),
     Is_true (is_e_of_e e1) ->
     Is_true (is_e_of_e e2) ->
     Is_true (is_T_of_T T_5) ->
     Is_true (is_T_of_T T1) ->
     algoSynth Gamma5 Theta5 e1 T1 V1 P1 ->
     algoSynth Gamma5 Theta5 e2 T_5 V2 P2 ->
     (formula_disjointList (varListListvListList ((app (cons V1 nil) (app (cons V2 nil) nil))))) ->
     algoSynth Gamma5 Theta5 (exprSeq e1 e2) T_5 (varListUnion V1 V2) (probListUnion P1 P2)
 | AlgoSynthAppArr : forall (X_alpha_list:list (X*alpha)) (Gamma5:Gamma) (Theta5:Theta) (e1 e2:e) (T_5:T) (V1 V2:V) (P1 P2 P3 P4:P) (pi5:pi) (T1:T),
     Is_true (is_e_of_e e1) ->
     Is_true (is_e_of_e e2) ->
     Is_true (is_T_of_T T_5) ->
     Is_true (is_pi_of_pi pi5) ->
     Is_true (is_T_of_T T1) ->
     synthNorm Gamma5 Theta5 e1 (T_polyarrow (map (fun (pat_:(X*alpha)) => match pat_ with (X_,alpha_) => X_ end ) X_alpha_list) pi5 T1 T_5) V1 P1 ->
     checkNorm Gamma5 Theta5 e2  (tsubst_T  (map (fun (pat_:(X*alpha)) => match pat_ with (X_,alpha_) => (X_,(T_unifVar alpha_)) end ) X_alpha_list)   T1 )  V2 P2 ->
     (formula_constrEq P3 (probListLiteral (cons (problemsKind Gamma5 Theta5  (tsubst_T  (map (fun (pat_:(X*alpha)) => match pat_ with (X_,alpha_) => (X_,(T_unifVar alpha_)) end ) X_alpha_list)    (  (T_polyarrow nil  pi5   T1   T_5 )  )  )  kind_KindStar) nil))) ->
     (formula_constrEq P4 (probListLiteral (cons (problemsEntails Gamma5 Theta5  (tsubst_pi  (map (fun (pat_:(X*alpha)) => match pat_ with (X_,alpha_) => (X_,(T_unifVar alpha_)) end ) X_alpha_list)   pi5 ) ) nil))) ->
     (formula_disjointList (varListListvListList ((app (cons V1 nil) (app (cons V2 nil) (app (map (fun (pat_:(X*alpha)) => match pat_ with (X_,alpha_) => (varListLiteral (cons alpha_ nil)) end ) X_alpha_list) nil)))))) ->
     algoSynth Gamma5 Theta5 (exprApp e1 e2)  (tsubst_T  (map (fun (pat_:(X*alpha)) => match pat_ with (X_,alpha_) => (X_,(T_unifVar alpha_)) end ) X_alpha_list)   T_5 )   TODOparsenvar   TODOparensconstrl 
 | AlgoSynthAppVar : forall (Gamma5:Gamma) (Theta5:Theta) (e1 e2:e) (alpha2:alpha) (V1 V2:V) (P1 P2 P3:P) (alpha_5 alpha1:alpha),
     Is_true (is_e_of_e e1) ->
     Is_true (is_e_of_e e2) ->
     algoSynth Gamma5 Theta5 e1 (T_unifVar alpha_5) V1 P1 ->
     algoCheck Gamma5 Theta5 e2 (T_unifVar alpha1) V2 P2 ->
     (formula_constrEq P3 (probListLiteral (cons (problemsEq Gamma5 Theta5 (T_unifVar alpha_5)  (T_polyarrow nil  pi_empty   (T_unifVar alpha1)   (T_unifVar alpha2) ) ) nil))) ->
     (formula_disjointList (varListListvListList ((app (cons V1 nil) (app (cons V2 nil) nil))))) ->
     algoSynth Gamma5 Theta5 (exprApp e1 e2) (T_unifVar alpha2)  TODOparsenvar   TODOparensconstrl 
 | AlgoSynthRef : forall (Gamma5:Gamma) (Theta5:Theta) (T5:T) (V5:V) (P5:P) (lv5:e),
     Is_true (is_lv_of_e lv5) ->
     Is_true (is_T_of_T T5) ->
     Is_true (is_lv_of_e lv5) ->
     algoSynth Gamma5 Theta5 lv5 T5 V5 P5 ->
     algoSynth Gamma5 Theta5 (exprRef lv5) (T_RefType T5) V5 P5
 | AlgoSynthAssign : forall (Gamma5:Gamma) (Theta5:Theta) (e5:e) (V1 V2:V) (P1 P2:P) (T5:T) (lv5:e),
     Is_true (is_lv_of_e lv5) ->
     Is_true (is_e_of_e e5) ->
     Is_true (is_T_of_T T5) ->
     Is_true (is_lv_of_e lv5) ->
     algoSynth Gamma5 Theta5 e5 T5 V1 P1 ->
     checkNorm Gamma5 Theta5 lv5 T5 V2 P2 ->
     (formula_disjointList (varListListvListList ((app (cons V1 nil) (app (cons V2 nil) nil))))) ->
     algoSynth Gamma5 Theta5 (exprAssign lv5 e5) T_UType (varListUnion V1 V2) (probListUnion P1 P2)
 | AlgoSynthStruct : forall (alpha_X_list:list (alpha*X)) (Gamma5:Gamma) (Theta5:Theta) (SName5:SName) (x1:exprvar) (e1:e) (x2:exprvar) (e2:e) (V1 V2:V) (P1 P2 P3:P) (T1 T2:T),
     Is_true (is_e_of_e e1) ->
     Is_true (is_e_of_e e2) ->
     Is_true (is_T_of_T T1) ->
     Is_true (is_T_of_T T2) ->
      (Exists_list (fun p => p =  (theta_item (itemstruct SName5 (map (fun (pat_:(alpha*X)) => match pat_ with (alpha_,X_) => X_ end ) alpha_X_list) x1 T1 x2 T2)) )  Theta5 )  ->
     (formula_constrEq P3 (probListLiteral (cons (problemsKind Gamma5 Theta5  (fold_right (fun ty accum => T_TyApp accum ty )   (T_StructType SName5)   (map (fun (pat_:(alpha*X)) => match pat_ with (alpha_,X_) => (T_unifVar alpha_) end ) alpha_X_list)  )  kind_KindStar) nil))) ->
     checkNorm Gamma5 Theta5 e1  (tsubst_T  (map (fun (pat_:(alpha*X)) => match pat_ with (alpha_,X_) => (X_,(T_unifVar alpha_)) end ) alpha_X_list)   T1 )  V1 P1 ->
     checkNorm Gamma5 Theta5 e2  (tsubst_T  (map (fun (pat_:(alpha*X)) => match pat_ with (alpha_,X_) => (X_,(T_unifVar alpha_)) end ) alpha_X_list)   T2 )  V2 P2 ->
     (formula_disjointList (varListListvListList ((app (cons V1 nil) (app (cons V2 nil) (app (map (fun (pat_:(alpha*X)) => match pat_ with (alpha_,X_) => (varListLiteral (cons alpha_ nil)) end ) alpha_X_list) nil)))))) ->
     algoSynth Gamma5 Theta5 (exprStructInit SName5 x1 e1 x2 e2)  (fold_right (fun ty accum => T_TyApp accum ty )   (T_StructType SName5)   (map (fun (pat_:(alpha*X)) => match pat_ with (alpha_,X_) => (T_unifVar alpha_) end ) alpha_X_list)  )   TODOparsenvar   TODOparensconstrl 
 | AlgoSynthProj : forall (X_tau_list:list (X*T)) (Gamma5:Gamma) (Theta5:Theta) (e5:e) (x1:exprvar) (T1:T) (V5:V) (P5:P) (SName5:SName) (x2:exprvar) (T2:T),
     Is_true (is_e_of_e e5) ->
     Is_true (is_T_of_T T1) ->
     Is_true (is_T_of_T T2) ->
     (Forall (fun (tmp_:(X*T)) => match tmp_ with (X_,tau_) => Is_true (is_tau_of_T tau_) end) X_tau_list) ->
     synthNorm Gamma5 Theta5 e5  (fold_right (fun ty accum => T_TyApp accum ty )   (T_StructType SName5)   (map (fun (pat_:(X*T)) => match pat_ with (X_,tau_) => tau_ end ) X_tau_list)  )  V5 P5 ->
      (Exists_list (fun p => p =  (theta_item (itemstruct SName5 (map (fun (pat_:(X*T)) => match pat_ with (X_,tau_) => X_ end ) X_tau_list) x1 T1 x2 T2)) )  Theta5 )  ->
     algoSynth Gamma5 Theta5 (exprStructField e5 x1)  (tsubst_T  X_tau_list   T1 )  V5 P5
 | AlgoSynthCtor : forall (alpha_X_list:list (alpha*X)) (Gamma5:Gamma) (Theta5:Theta) (CtorName_5:CtorName) (EnumName5:EnumName) (e5:e) (V5:V) (P_5 P2:P) (CtorName1:CtorName) (T1:T) (CtorName2:CtorName) (T2 T_5:T),
     Is_true (is_e_of_e e5) ->
     Is_true (is_T_of_T T1) ->
     Is_true (is_T_of_T T2) ->
     Is_true (is_T_of_T T_5) ->
      (Exists_list (fun p => p =  (theta_item (itemenum EnumName5 (map (fun (pat_:(alpha*X)) => match pat_ with (alpha_,X_) => X_ end ) alpha_X_list) CtorName1 T1 CtorName2 T2)) )  Theta5 )  ->
     (formula_cchoiceT CtorName_5 T_5 CtorName1 T1 CtorName2 T2) ->
     (formula_constrEq P2 (probListLiteral (cons (problemsKind Gamma5 Theta5  (fold_right (fun ty accum => T_TyApp accum ty )   (T_EnumType EnumName5)   (map (fun (pat_:(alpha*X)) => match pat_ with (alpha_,X_) => (T_unifVar alpha_) end ) alpha_X_list)  )  kind_KindStar) nil))) ->
     checkNorm Gamma5 Theta5 e5  (tsubst_T  (map (fun (pat_:(alpha*X)) => match pat_ with (alpha_,X_) => (X_,(T_unifVar alpha_)) end ) alpha_X_list)   T_5 )  V5 P_5 ->
     algoSynth Gamma5 Theta5 (exprCApp CtorName_5 EnumName5 e5)  (fold_right (fun ty accum => T_TyApp accum ty )   (T_EnumType EnumName5)   (map (fun (pat_:(alpha*X)) => match pat_ with (alpha_,X_) => (T_unifVar alpha_) end ) alpha_X_list)  )   TODOparsenvar  (probListUnion P_5 P2)
 | AlgoSynthMatch : forall (alpha_X_list:list (alpha*X)) (Gamma5:Gamma) (Theta5:Theta) (e_5:e) (CtorName1:CtorName) (EnumName5:EnumName) (x1:exprvar) (e1:e) (CtorName2:CtorName) (x2:exprvar) (e2:e) (T_5:T) (V1 V2 V3:V) (P1 P2 P3 P4:P) (T1 T2 T'1 T'2:T),
     Is_true (is_e_of_e e_5) ->
     Is_true (is_e_of_e e1) ->
     Is_true (is_e_of_e e2) ->
     Is_true (is_T_of_T T_5) ->
     Is_true (is_T_of_T T1) ->
     Is_true (is_T_of_T T2) ->
     Is_true (is_T_of_T T'1) ->
     Is_true (is_T_of_T T'2) ->
      (Exists_list (fun p => p =  (theta_item (itemenum EnumName5 (map (fun (pat_:(alpha*X)) => match pat_ with (alpha_,X_) => X_ end ) alpha_X_list) CtorName1 T1 CtorName2 T2)) )  Theta5 )  ->
     synthNorm Gamma5 Theta5 e_5 T_5 V1 P1 ->
     algoSynth  (  (cons (gamma_evar x1  (tsubst_T  (map (fun (pat_:(alpha*X)) => match pat_ with (alpha_,X_) => (X_,(T_unifVar alpha_)) end ) alpha_X_list)   T1 ) ) nil)  ++  Gamma5  )  Theta5 e1 T'1 V2 P2 ->
     algoSynth  (  (cons (gamma_evar x2  (tsubst_T  (map (fun (pat_:(alpha*X)) => match pat_ with (alpha_,X_) => (X_,(T_unifVar alpha_)) end ) alpha_X_list)   T2 ) ) nil)  ++  Gamma5  )  Theta5 e2 T'2 V3 P3 ->
     (formula_constrEq P4 (probListLiteral ((app (cons (problemsEq Gamma5 Theta5 T_5  (fold_right (fun ty accum => T_TyApp accum ty )   (T_EnumType EnumName5)   (map (fun (pat_:(alpha*X)) => match pat_ with (alpha_,X_) => (T_unifVar alpha_) end ) alpha_X_list)  ) ) nil) (app (cons (problemsEq Gamma5 Theta5 T'1 T'2) nil) nil))))) ->
     (formula_disjointList (varListListvListList ((app (cons V1 nil) (app (cons V2 nil) (app (cons V3 nil) (app (cons (varListLiteral (map (fun (pat_:(alpha*X)) => match pat_ with (alpha_,X_) => alpha_ end ) alpha_X_list)) nil) nil))))))) ->
     algoSynth Gamma5 Theta5 (exprmatch e_5 CtorName1 EnumName5 x1 e1 CtorName2 EnumName5 x2 e2) T_5  TODOparsenvar   TODOparensconstrl 
with smallStep : Theta -> e -> sigma -> e -> sigma -> Prop :=    (* defn smallStep *)
 | StepContext : forall (Theta5:Theta) (EC5:EC) (e1:e) (sigma1:sigma) (e2:e) (sigma2:sigma),
     Is_true (is_EC_of_EC EC5) ->
     Is_true (is_e_of_e e1) ->
     Is_true (is_e_of_e e2) ->
     smallStep Theta5 e1 sigma1 e2 sigma2 ->
     smallStep Theta5  (appctx_EC_expr  EC5   e1 )  sigma1  (appctx_EC_expr  EC5   e2 )  sigma2
 | StepLoc : forall (Theta5:Theta) (loc5:loc) (sigma1:sigma) (v5:e) (sigma_5:sigma),
     Is_true (is_v_of_e v5) ->
      (lookup  loc5   sigma_5  = Some  v5 )  ->
     smallStep Theta5 (exprInternal (internalloc loc5)) sigma1 v5 sigma1
 | StepDeref : forall (Theta5:Theta) (sigma1:sigma) (v5:e) (sigma2:sigma) (lv5:e),
     Is_true (is_lv_of_e lv5) ->
     Is_true (is_v_of_e v5) ->
     Is_true (is_lv_of_e lv5) ->
     smallStep Theta5 lv5 sigma1 v5 sigma2 ->
     smallStep Theta5 (exprDeref  ( (exprRef lv5) ) ) sigma1 v5 sigma2
 | StepStructVar : forall (Theta5:Theta) (lv5:e) (x:exprvar) (sigma1:sigma) (v5:e) (sigma2:sigma),
     Is_true (is_lv_of_e lv5) ->
     Is_true (is_v_of_e v5) ->
     smallStep Theta5 lv5 sigma1 v5 sigma2 ->
     smallStep Theta5 (exprStructField lv5 x) sigma1 (exprStructField v5 x) sigma2
 | StepStruct : forall (Theta5:Theta) (SName5:SName) (x1:exprvar) (v1:e) (x2:exprvar) (v2:e) (x:exprvar) (sigma5:sigma) (v_5:e),
     Is_true (is_v_of_e v1) ->
     Is_true (is_v_of_e v2) ->
     Is_true (is_v_of_e v_5) ->
     (formula_schoicee x v_5 x1 v1 x2 v2) ->
     smallStep Theta5 (exprStructField (exprStructInit SName5 x1 v1 x2 v2) x) sigma5 v_5 sigma5
 | StepAssignLoc : forall (Theta5:Theta) (loc5:loc) (sigma5:sigma) (v5:e),
     Is_true (is_v_of_e v5) ->
     Is_true (is_v_of_e v5) ->
     smallStep Theta5  ( (exprAssign (exprInternal (internalloc loc5)) v5) )  sigma5 exprUnit  (add  loc5   v5   sigma5 ) 
 | StepAssignStruct : forall (Theta5:Theta) (x:exprvar) (v_5:e) (sigma_5:sigma) (SName5:SName) (x2:exprvar) (v2:e) (sigma3:sigma) (lv5 v1:e) (sigma2:sigma),
     Is_true (is_lv_of_e lv5) ->
     Is_true (is_v_of_e v_5) ->
     Is_true (is_v_of_e v2) ->
     Is_true (is_lv_of_e lv5) ->
     Is_true (is_v_of_e v1) ->
     smallStep Theta5 lv5 sigma_5 (exprStructInit SName5 x v1 x2 v2) sigma2 ->
     smallStep Theta5 (exprAssign (exprStructField lv5 x) v_5) sigma_5 (exprAssign lv5 (exprStructInit SName5 x v_5 x2 v2)) sigma3
 | StepAssignDeref : forall (Theta5:Theta) (lv5 v5:e) (sigma5:sigma),
     Is_true (is_lv_of_e lv5) ->
     Is_true (is_v_of_e v5) ->
     smallStep Theta5 (exprAssign (exprDeref  ( (exprRef lv5) ) ) v5) sigma5 (exprAssign lv5 v5) sigma5
 | StepLet : forall (Theta5:Theta) (x:exprvar) (e5:e) (sigma5:sigma) (loc5:loc) (v5:e),
     Is_true (is_v_of_e v5) ->
     Is_true (is_e_of_e e5) ->
     Is_true (is_v_of_e v5) ->
     (formula_freshloc sigma5 loc5) ->
     smallStep Theta5 (exprLet x v5 e5) sigma5  (esubst_expr  x   (exprInternal (internalloc loc5))   e5 )   (add  loc5   v5   sigma5 ) 
 | StepMatch : forall (Theta5:Theta) (CtorName_5:CtorName) (EnumName5:EnumName) (v5:e) (CtorName1:CtorName) (x1:exprvar) (e1:e) (CtorName2:CtorName) (x2:exprvar) (e2:e) (sigma1:sigma) (x:exprvar) (e_5:e) (sigma_5:sigma),
     Is_true (is_v_of_e v5) ->
     Is_true (is_e_of_e e1) ->
     Is_true (is_e_of_e e2) ->
     Is_true (is_e_of_e e_5) ->
     (formula_cchoicee CtorName_5 e_5 x CtorName1 e1 x1 CtorName2 e2 x2) ->
     smallStep Theta5 (exprmatch (exprCApp CtorName_5 EnumName5 v5) CtorName1 EnumName5 x1 e1 CtorName2 EnumName5 x2 e2) sigma1 (exprLet x v5 e_5) sigma_5
 | StepCall : forall (Theta5:Theta) (x:exprvar) (T1:T) (e5:e) (T2:T) (sigma5:sigma) (loc5:loc) (v5:e),
     Is_true (is_T_of_T T1) ->
     Is_true (is_e_of_e e5) ->
     Is_true (is_T_of_T T2) ->
     Is_true (is_v_of_e v5) ->
     Is_true (is_v_of_e v5) ->
     (formula_freshloc sigma5 loc5) ->
     smallStep Theta5 (exprApp  ( (exprInternal (internalRawProc x T1 e5 T2)) )  v5) sigma5  (esubst_expr  x   (exprInternal (internalloc loc5))   e5 )   (add  loc5   v5   sigma5 ) 
 | StepFn : forall (Theta5:Theta) (f:exprvar) (sigma5:sigma) (e5:e),
     Is_true (is_e_of_e e5) ->
      (Exists_list (fun p => p =  (theta_fnval f e5) )  Theta5 )  ->
     smallStep Theta5 (exprVar f) sigma5 e5 sigma5
 | StepMethod : forall (tau''_list tau_list:list T) (Theta5:Theta) (f:exprvar) (tau_5:T) (sigma5:sigma) (e5:e) (D5:D),
     Is_true (is_tau_of_T tau_5) ->
     Is_true (is_e_of_e e5) ->
     (Forall (fun (tau''_:T) => Is_true (is_tau_of_T tau''_)) tau''_list) ->
     (Forall (fun (tau_:T) => Is_true (is_tau_of_T tau_)) tau_list) ->
     entail  nil  Theta5 (pi_trtBound tau_5  ( (beta_elab  TODOsugar1  f e5) ) ) ->
     smallStep Theta5 (exprInternal (internalspec (exprVar f) ((app (cons tau_5 nil) (app tau_list (app tau''_list nil)))))) sigma5 (exprInternal (internalspec e5 tau''_list)) sigma5
 | StepObjApp : forall (Theta5:Theta) (X5:X) (beta5:beta) (e1:e) (T5:T) (f:exprvar) (e2:e) (sigma5:sigma) (v5:e),
     Is_true (is_beta_of_beta beta5) ->
     Is_true (is_e_of_e e1) ->
     Is_true (is_T_of_T T5) ->
     Is_true (is_v_of_e v5) ->
     Is_true (is_e_of_e e2) ->
     Is_true (is_v_of_e v5) ->
     smallStep Theta5 (exprInternal (internalobjapp (exprInternal (internalobj X5 beta5 e1 T5 f v5)) f e2)) sigma5 (exprApp v5 (exprTuple e1 e2)) sigma5
 | StepInst : forall (X_tau_list:list (X*T)) (Theta5:Theta) (e5:e) (sigma5:sigma),
     Is_true (is_e_of_e e5) ->
     (Forall (fun (tmp_:(X*T)) => match tmp_ with (X_,tau_) => Is_true (is_tau_of_T tau_) end) X_tau_list) ->
     smallStep Theta5 (exprInternal (internalspec  ( (exprInternal (internalgen (map (fun (pat_:(X*T)) => match pat_ with (X_,tau_) => X_ end ) X_tau_list) e5)) )  (map (fun (pat_:(X*T)) => match pat_ with (X_,tau_) => tau_ end ) X_tau_list))) sigma5  (  (tsubst_expr  X_tau_list   e5 )  )  sigma5
 | StepSeq : forall (Theta5:Theta) (v5 e5:e) (sigma1:sigma),
     Is_true (is_v_of_e v5) ->
     Is_true (is_e_of_e e5) ->
     smallStep Theta5  ( (exprSeq v5 e5) )  sigma1 e5 sigma1
with ItemType : Gamma -> Theta -> item -> Gamma -> Theta -> Prop :=    (* defn ItemType *)
 | ItemTypeStruct : forall (X_list:list X) (Gamma5:Gamma) (Theta5:Theta) (SName5:SName) (x1:exprvar) (T1:T) (x2:exprvar) (T2:T),
     Is_true (is_T_of_T T1) ->
     Is_true (is_T_of_T T2) ->
     HasKind  (  (map (fun (X_:X) => (gamma_tvar X_)) X_list)  ++  Gamma5  )  Theta5 (kinded_type T1) kind_KindStar ->
     HasKind  (  (map (fun (X_:X) => (gamma_tvar X_)) X_list)  ++  Gamma5  )  Theta5 (kinded_type T2) kind_KindStar ->
     ItemType Gamma5 Theta5 (itemstruct SName5 X_list x1 T1 x2 T2)  nil   nil 
 | ItemTypeEnum : forall (X_list:list X) (Gamma5:Gamma) (Theta5:Theta) (EnumName5:EnumName) (CtorName1:CtorName) (T1:T) (CtorName2:CtorName) (T2:T),
     Is_true (is_T_of_T T1) ->
     Is_true (is_T_of_T T2) ->
     HasKind  (  (map (fun (X_:X) => (gamma_tvar X_)) X_list)  ++  Gamma5  )  Theta5 (kinded_type T1) kind_KindStar ->
     HasKind  (  (map (fun (X_:X) => (gamma_tvar X_)) X_list)  ++  Gamma5  )  Theta5 (kinded_type T2) kind_KindStar ->
     ItemType Gamma5 Theta5 (itemenum EnumName5 X_list CtorName1 T1 CtorName2 T2)  nil   nil 
 | ItemTypeFun : forall (X_list:list X) (Gamma5:Gamma) (Theta5:Theta) (f x:exprvar) (T1 T2:T) (pi5:pi) (e5:e) (T0:T) (e':e),
     Is_true (is_T_of_T T1) ->
     Is_true (is_T_of_T T2) ->
     Is_true (is_pi_of_pi pi5) ->
     Is_true (is_e_of_e e5) ->
     Is_true (is_T_of_T T0) ->
     Is_true (is_e_of_e e') ->
     check  (  (cons (gamma_evar x T1) nil)  ++   (  (  (map (fun (X_:X) => (gamma_tvar X_)) X_list)  ++  Gamma5  )  )   )   (  (cons (theta_pi pi5) nil)  ++  Theta5  )  e5 e' T2 ->
      ( T0  =  (T_polyarrow X_list pi5 T1 T2)  )  ->
     ItemType Gamma5 Theta5 (itemfundef (fundef_fundef f X_list x T1 T2 pi5 e5)) (Gamma_join (cons (gamma_evar f T0) nil))  TODOtheta 
 | ItemTypeTraitObjSafe : forall (X''_list X_list:list X) (UNK: NUM 0:UNK_CTP) (Gamma5:Gamma) (Theta5:Theta) (D5:D) (pi5:pi) (X':X) (fundecl5:fundecl) (f:exprvar) (T''':T) (theta5:theta) (x:exprvar) (T1 T2:T) (pi':pi) (T1':T) (X'0:X) (e5:e) (tau0:T) (t106 t107 t108 t109 t110 t111 t112 t113:X),
          nth_error X_list 0 = Some t106 ->
     nth_error X_list 0 = Some t107 ->
     nth_error X_list 0 = Some t108 ->
     nth_error X_list 0 = Some t109 ->
     nth_error X_list 0 = Some t110 ->
     nth_error X_list 0 = Some t111 ->
     nth_error X_list 0 = Some t112 ->
     nth_error X_list 0 = Some t113 ->
Is_true (is_pi_of_pi pi5) ->
     Is_true (is_fundecl_of_fundecl fundecl5) ->
     Is_true (is_T_of_T T''') ->
     Is_true (is_theta_of_theta theta5) ->
     Is_true (is_T_of_T T1) ->
     Is_true (is_T_of_T T2) ->
     Is_true (is_pi_of_pi pi') ->
     Is_true (is_T_of_T T1') ->
     Is_true (is_tau_of_T tau0) ->
     Is_true (is_e_of_e e5) ->
     Is_true (is_tau_of_T tau0) ->
     (formula_fundecleq fundecl5 (fundecl_fundecl f X''_list x T1 T2 pi')) ->
      ( T1  =   ( (T_Tuple  ( (T_RefType (T_var t106)) )  T1') )   )  ->
     HasKind Gamma5 Theta5 (kinded_constr pi5) kind_Constr ->
     HasKind  (  (cons (gamma_tvar X') nil)  ++   (  (  (cons (gamma_tvar t107) nil)  ++   (  (  (map (fun (X_:X) => (gamma_tvar X_)) X_list)  ++  Gamma5  )  )   )  )   )   (  (cons (theta_pi pi5) nil)  ++  Theta5  )  (kinded_type (T_polyarrow X''_list pi' T1 T2)) kind_KindStar ->
     HasKind  (  (  (map (fun (X''_:X) => (gamma_tvar X''_)) X''_list)  ++   (  (  (cons (gamma_tvar X') nil)  ++   (  (  (map (fun (X_:X) => (gamma_tvar X_)) X_list)  ++  Gamma5  )  )   )  )   )  )   (  (cons (theta_pi pi5) nil)  ++  Theta5  )  (kinded_type T2) kind_KindStar ->
      ( tau0  =  (T_TraitObj t108  (fold_right (fun tau accum => beta_TypeApp accum tau ) 
    (fold_right 
      (fun pair accum => beta_Assoc accum (fst pair) (snd pair) )
      (beta_TraitName  D5 )
      (  X'   )  (T_var X'0)  
    ) 
     (map (fun (X_:X) => (T_var X_)) X_list) ) )  )  ->
     (formula_eeq e5 (exprInternal (internalgen X''_list (exprInternal (internalRawProc x  ( (T_Tuple (T_var t109) T1') )  (exprInternal (internalobjapp (exprDeref  ( (exprfst (exprVar x)) ) ) f (exprsnd (exprVar x)))) T2))))) ->
     (formula_thetaeq theta5 (theta_pi (pi_forall ((app (cons t110 nil) (app (cons X'0 nil) (app X_list nil))))  (tsubst_pi  (cons (X',(T_var X'0)) nil)   pi5 )  tau0 (beta_elab  (fold_right (fun tau accum => beta_TypeApp accum tau ) 
    (fold_right 
      (fun pair accum => beta_Assoc accum (fst pair) (snd pair) )
      (beta_TraitName  D5 )
      (  X'   )  (T_var X'0)  
    ) 
     (map (fun (X_:X) => (T_var X_)) X_list) )  f e5)))) ->
      ( T'''  =  (T_polyarrow ((app (cons t112 nil) (app X_list (app X''_list nil)))) (pi_conj (pi_trtBound (T_var t111)  TODOsugar1 ) pi') T1 T2)  )  ->
     ItemType Gamma5 Theta5 (itemtraitdecl D5 ((app (cons t113 nil) (app X_list nil))) pi5 X' fundecl5) (Gamma_join (cons (gamma_evar f T''') nil))  TODOtheta 
 | ItemTypeTraitObjUnSafe : forall (X''_list X_list:list X) (UNK: NUM 0:UNK_CTP) (Gamma5:Gamma) (Theta5:Theta) (D5:D) (pi5:pi) (X':X) (fundecl5:fundecl) (f:exprvar) (T''':T) (x:exprvar) (T1 T2:T) (pi':pi) (t114 t115 t116 t117:X),
          nth_error X_list 0 = Some t114 ->
     nth_error X_list 0 = Some t115 ->
     nth_error X_list 0 = Some t116 ->
     nth_error X_list 0 = Some t117 ->
Is_true (is_pi_of_pi pi5) ->
     Is_true (is_fundecl_of_fundecl fundecl5) ->
     Is_true (is_T_of_T T''') ->
     Is_true (is_T_of_T T1) ->
     Is_true (is_T_of_T T2) ->
     Is_true (is_pi_of_pi pi') ->
     HasKind Gamma5 Theta5 (kinded_constr pi5) kind_Constr ->
     (formula_fundecleq fundecl5 (fundecl_fundecl f X''_list x T1 T2 pi')) ->
     HasKind  (  (cons (gamma_tvar X') nil)  ++   (  (  (cons (gamma_tvar t114) nil)  ++   (  (  (map (fun (X_:X) => (gamma_tvar X_)) X_list)  ++  Gamma5  )  )   )  )   )   (  (cons (theta_pi pi5) nil)  ++  Theta5  )  (kinded_type (T_polyarrow X''_list pi' T1 T2)) kind_KindStar ->
      ( T'''  =  (T_polyarrow ((app (cons t116 nil) (app X_list (app X''_list nil)))) (pi_conj (pi_trtBound (T_var t115)  TODOsugar1 ) pi') T1 T2)  )  ->
     ItemType Gamma5 Theta5 (itemtraitdecl D5 ((app (cons t117 nil) (app X_list nil))) pi5 X' fundecl5) (Gamma_join (cons (gamma_evar f T''') nil))  nil 
 | ItemTypeImpl : forall (Y_list:list X) (tau_X''_list:list (T*X)) (X_list:list X) (Gamma5:Gamma) (Theta5:Theta) (D5:D) (pi0:pi) (X':X) (fundef5:fundef) (theta5:theta) (pi1:pi) (fundecl5:fundecl) (tau':T) (f x:exprvar) (T1 T2:T) (pi2:pi) (T'1 T'2:T) (pi'2:pi) (e5 e':e) (tau_5:T),
     Is_true (is_tau_of_T tau_5) ->
     Is_true (is_pi_of_pi pi0) ->
     Is_true (is_tau_of_T tau') ->
     Is_true (is_fundef_of_fundef fundef5) ->
     Is_true (is_theta_of_theta theta5) ->
     Is_true (is_pi_of_pi pi1) ->
     Is_true (is_fundecl_of_fundecl fundecl5) ->
     Is_true (is_tau_of_T tau') ->
     Is_true (is_T_of_T T1) ->
     Is_true (is_T_of_T T2) ->
     Is_true (is_pi_of_pi pi2) ->
     Is_true (is_T_of_T T'1) ->
     Is_true (is_T_of_T T'2) ->
     Is_true (is_pi_of_pi pi'2) ->
     Is_true (is_e_of_e e5) ->
     Is_true (is_e_of_e e') ->
     Is_true (is_tau_of_T tau_5) ->
     (Forall (fun (tmp_:(T*X)) => match tmp_ with (tau_,X''_) => Is_true (is_tau_of_T tau_) end) tau_X''_list) ->
     HasKind Gamma5 Theta5 (kinded_constr pi0) kind_Constr ->
     HasKind Gamma5 Theta5 (kinded_type tau_5) kind_KindStar ->
     HasKind  (  (map (fun (X_:X) => (gamma_tvar X_)) X_list)  ++  Gamma5  )  Theta5 (kinded_type tau')  (kindOf X' )  ->
      (Exists_list (fun p => p =  (theta_item (itemtraitdecl D5 (map (fun (pat_:(T*X)) => match pat_ with (tau_,X''_) => X''_ end ) tau_X''_list) pi1 X' fundecl5)) )  Theta5 )  ->
     entail Gamma5  (  (cons (theta_pi pi0) nil)  ++  Theta5  )   (tsubst_pi  (map (fun (pat_:(T*X)) => match pat_ with (tau_,X''_) => (X''_,tau_) end ) tau_X''_list)    (tsubst_pi  (cons (X',tau') nil)   pi1 )  )  ->
     (formula_fundecleq fundecl5 (fundecl_fundecl f Y_list x T1 T2 pi2)) ->
      ( T'1  =   (tsubst_T  (map (fun (pat_:(T*X)) => match pat_ with (tau_,X''_) => (X''_,tau_) end ) tau_X''_list)    (tsubst_T  (cons (X',tau') nil)   T1 )  )   )  ->
      ( T'2  =   (tsubst_T  (map (fun (pat_:(T*X)) => match pat_ with (tau_,X''_) => (X''_,tau_) end ) tau_X''_list)    (tsubst_T  (cons (X',tau') nil)   T2 )  )   )  ->
     (formula_thetaeq (theta_pi pi'2) (theta_pi  (tsubst_pi  (map (fun (pat_:(T*X)) => match pat_ with (tau_,X''_) => (X''_,tau_) end ) tau_X''_list)    (tsubst_pi  (cons (X',tau') nil)   pi2 )  ) )) ->
     (formula_thetaeq (theta_item (itemfundef fundef5)) (theta_item (itemfundef (fundef_fundef f Y_list x T'1 T'2 pi'2 e5)))) ->
     check  (  (cons (gamma_evar x T'1) nil)  ++   (  (  (map (fun (Y_:X) => (gamma_tvar Y_)) Y_list)  ++   (  (  (map (fun (X_:X) => (gamma_tvar X_)) X_list)  ++  Gamma5  )  )   )  )   )   (  (cons (theta_pi (pi_conj pi0 pi'2)) nil)  ++  Theta5  )  e5 e' T'2 ->
     (formula_thetaeq theta5 (theta_pi (pi_forall X_list pi0 tau_5  ( (beta_elab  TODOsugar1  f (exprInternal (internalgen Y_list e'))) ) ))) ->
     ItemType Gamma5 Theta5 (itemtraitimpl X_list D5 (map (fun (pat_:(T*X)) => match pat_ with (tau_,X''_) => tau_ end ) tau_X''_list) tau_5 pi0 X' tau' fundef5)  nil   TODOtheta 
with Wf : Gamma -> Theta -> Prop :=    (* defn Wf *)
 | WfEmpty : 
     Wf  nil   nil 
 | WfExtGamma : forall (Gamma5:Gamma) (x:exprvar) (T5:T) (Theta5:Theta),
     Is_true (is_T_of_T T5) ->
     Wf Gamma5 Theta5 ->
     HasKind Gamma5 Theta5 (kinded_type T5) kind_KindStar ->
     Wf  (  (cons (gamma_evar x T5) nil)  ++  Gamma5  )  Theta5
 | WfExtTheta : forall (Gamma5:Gamma) (Theta5:Theta) (pi5:pi),
     Is_true (is_pi_of_pi pi5) ->
     Wf Gamma5 Theta5 ->
     HasKind Gamma5 Theta5 (kinded_constr pi5) kind_Constr ->
     Wf Gamma5  (  (cons (theta_pi pi5) nil)  ++  Theta5  ) 
 | WfItem : forall (Gamma5 Gamma':Gamma) (Theta5:Theta) (item5:item) (Theta':Theta),
     Is_true (is_item_of_item item5) ->
     ItemType Gamma5 Theta5 item5 Gamma' Theta' ->
     Wf  TODO   TODO .


